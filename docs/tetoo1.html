<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>オンラインテトリス（非完全）</title>
  <style>
    body {
      background: #d0f0ff;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      /* ボタンの高さ＋余白分をbodyのpadding-bottomに設定 */
      padding-bottom: 240px;
      /* ボタンが上に移動したので余白を増やす */
    }

    #menu {
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .btn {
      padding: 10px 20px;
      background: #a0e0ff;
      border: none;
      border-radius: 5px;
      margin: 5px;
      font-size: 16px;
      cursor: pointer;
    }

    .btn.selected {
      background: #66bde3;
      color: white;
      font-weight: bold;
    }

    /* レイアウトの変更: Flexboxを最大限に活用 */
    #wrapper {
      display: flex;
      flex-direction: row;
      /* 要素を横並びに */
      gap: 10px;
      /* 要素間のスペース */
      padding: 10px;
      justify-content: center;
      /* 中央揃え */
      align-items: flex-start;
      /* 上揃え */
    }

    canvas {
      background: #fff;
      border: 2px solid #a0e0ff;
    }

    /* 各キャンバスのサイズはそのまま */
    #next,
    #opponentNext {
      width: 80px;
      height: 160px;
    }

    #hold,
    #opponentHold {
      width: 80px;
      height: 80px;
    }

    #tetris,
    #opponent {
      width: 200px;
      height: 400px;
    }

    #garbage-indicator {
      width: 20px;
      height: 400px;
    }

    /* サイドカラムのスタイル */
    .side-column {
      display: flex;
      flex-direction: column;
      /* 縦に並べる */
      align-items: center;
      gap: 10px;
      /* 要素間のスペース */
    }

    /* ボタンの配置とサイズを調整 */
    .controls {
      position: fixed;
      /* 画面に固定 */
      bottom: 70px;
      /* 画面下からの位置を調整 */
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      /* 新しい配置 */
      grid-template-areas:
        "rotL hard rotR hold"
        "left down right hold";
      gap: 10px;
      grid-template-columns: repeat(3, 60px) 100px;
      /* 3列は60px、4列目（HOLD）は100px */
      z-index: 10;
      padding: 10px;
      /* 見栄えを良くするため */
      background-color: rgba(255, 255, 255, 0.7);
      /* ボタン領域の背景 */
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      /* 影を追加して浮き上がらせる */
      /* 初期は非表示 */
      display: none;
    }

    .btn-control {
      width: 60px;
      height: 60px;
      font-size: 18px;
      background: #e0f2f7;
      border: 1px solid #b2ebf2;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      display: flex;
      /* 中央揃えのため */
      justify-content: center;
      /* 中央揃えのため */
      align-items: center;
      /* 中央揃えのため */
      font-weight: bold;
      /* 文字を太く */
      user-select: none;
      /* テキスト選択を無効化（スマホでの誤操作防止） */
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
      /* タップ時のハイライトを無効化 */
    }

    /* 各ボタンのグリッドエリア指定 */
    .btn-rotate-left {
      grid-area: rotL;
    }

    .btn-hard-drop {
      grid-area: hard;
    }

    .btn-rotate-right {
      grid-area: rotR;
    }

    .btn-left {
      grid-area: left;
    }

    .btn-right {
      grid-area: right;
    }

    .btn-down {
      grid-area: down;
    }

    .btn-hold {
      grid-area: hold;
      height: 130px;
      /* 2行分を占めるように高さを調整 (60px * 2 + 10px gap) */
      width: 100px;
      /* 幅を調整 */
      font-size: 20px;
      /* 文字を少し大きく */
    }

    /* 待機画面のスタイル */
    #waiting-screen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      background-color: rgba(255, 255, 255, 0.9);
      z-index: 100;
    }

    #waitingRoomId {
      font-size: 1.5em;
      margin-bottom: 20px;
    }
  </style>
</head>

<body>
  <div id="menu">
    <h1>オンラインテトリス</h1>
    <input id="playerName" placeholder="名前を入力" />
    <div>
      <button id="btn-gesture" class="btn selected" onclick="setControlMode('gesture')">ジェスチャー</button>
      <button id="btn-button" class="btn" onclick="setControlMode('button')">ボタン</button>
    </div>
    <button class="btn" onclick="hostRoom()">部屋を作成</button>
    <input id="roomCode" placeholder="ルームコード" />
    <button class="btn" onclick="joinRoom()">参加</button>
  </div>

  <div id="waiting-screen"
    style="display:none; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background-color: rgba(255,255,255,0.9); position: absolute; top: 0; left: 0; width: 100%; z-index: 100;">
    <div id="waitingRoomId" style="font-size: 1.5em; margin-bottom: 20px;"></div>
    <p>参加者を待っています...</p>
  </div>

  <div id="wrapper" style="display:none;">
    <div class="side-column">
      <canvas id="next" width="80" height="160"></canvas>
      <canvas id="hold" width="80" height="80"></canvas>
    </div>

    <canvas id="tetris" width="200" height="400"></canvas>

    <canvas id="garbage-indicator" width="20" height="400"></canvas>

    <canvas id="opponent" width="200" height="400"></canvas>

    <div class="side-column">
      <canvas id="opponentNext" width="80" height="160"></canvas>
      <canvas id="opponentHold" width="80" height="80"></canvas>
    </div>
  </div>

  <div id="touch-controls" class="controls">
    <button class="btn-control btn-rotate-left" onclick="playerRotate(-1)">左回転</button>
    <button class="btn-control btn-hard-drop" onclick="hardDrop()">↑</button>
    <button class="btn-control btn-rotate-right" onclick="playerRotate(1)">右回転</button>
    <button class="btn-control btn-hold" onclick="holdPiece()">HOLD</button>

    <button class="btn-control btn-left" onclick="playerMove(-1)">←</button>
    <button class="btn-control btn-down" onmousedown="startSoftDrop()" onmouseup="stopSoftDrop()"
      ontouchstart="startSoftDrop()" ontouchend="stopSoftDrop()">↓</button>
    <button class="btn-control btn-right" onclick="playerMove(1)">→</button>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBaAc1roVYEaokLoCSbg80uFzOF2YL53q8",
      authDomain: "online-tetris1.firebaseapp.com",
      databaseURL: "https://online-tetris1-default-rtdb.firebaseio.com",
      projectId: "online-tetris1",
      storageBucket: "online-tetris1.appspot.com",
      messagingSenderId: "869783174259",
      appId: "1:869783174259:web:4eb1624226d88f91cffe06"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let roomId = "";
    let isHost = false;
    let myRoleRef = null; // 自分のFirebase上の参照 (host or guest)
    let opponentRoleRef = null; // 相手のFirebase上の参照
    let myConnectedListener = null; // 自分のconnected状態を監視するリスナー
    let controlMode = "gesture"; // デフォルトはジェスチャー

    let opponentMatrix = Array.from({
      length: 20
    }, () => Array(10).fill(0)); // 相手の積まれた盤面を保持する配列

    let opponentPlayerType = null; // 相手の落ちているテトリミノの型
    let opponentPlayerPosition = null; // 相手の落ちているテトリミノの位置
    let opponentNextPieces = []; // 相手の次のピースのタイプ (配列に変更)
    let opponentHoldPiece = null; // 相手のホールドピースのタイプ

    let incomingGarbage = 0; // おじゃまラインの数
    let gameStarted = false; // ゲームが開始されたことを示すフラグ
    let opponentConnectedListener = null; // 相手が接続したか/切断したかを監視するリスナー

    // ゲームループ関連の変数
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let animationFrameId = null;
    let softDropInterval = null; // ソフトドロップ用のインターバルID

    // タッチ入力関連の変数
    let touchStartX = 0,
      touchStartY = 0;
    const swipeThreshold = 30; // スワイプの閾値
    const canvas = document.getElementById("tetris"); // canvas要素を取得

    // キーボードイベントリスナー
    document.addEventListener("keydown", (e) => {
      if (!gameStarted) return; // ゲームが開始されていない場合は操作を無効化
      if (e.key === "ArrowLeft") playerMove(-1);
      else if (e.key === "ArrowRight") playerMove(1);
      else if (e.key === "ArrowDown") startSoftDrop();
      else if (e.key === "ArrowUp") hardDrop();
      else if (e.key === "z") playerRotate(-1);
      else if (e.key === "x") playerRotate(1);
      else if (e.key === "c") holdPiece();
    });

    document.addEventListener("keyup", (e) => {
      if (!gameStarted) return; // ゲームが開始されていない場合は操作を無効化
      if (e.key === "ArrowDown") stopSoftDrop();
    });

    // 自分の接続状態をFirebaseに書き込むリスナー (Firebase公式のプレゼンスシステム)
    // このリスナーはFirebaseの接続状態を監視するだけで、connected状態を直接設定しない
    db.ref('.info/connected').on('value', (snapshot) => {
      if (snapshot.val() === true) {
        console.log("[Firebase Connected] 接続が確立されました。");
      } else {
        console.log("[Firebase Connected] 接続が切断されました。");
      }
    });

    // 自分のconnected状態がtrueになるまで待機するヘルパー関数
    function waitForMyConnected() {
      return new Promise((resolve, reject) => {
        if (!myRoleRef) {
          console.error("[waitForMyConnected] myRoleRefが設定されていません。");
          return reject("myRoleRef not set.");
        }

        const connectedValueListener = (snapshot) => {
          const isConnected = snapshot.val();
          console.log(`[waitForMyConnected] 自分のconnected状態: ${isConnected}`);
          if (isConnected === true) {
            myRoleRef.child("connected").off("value", connectedValueListener);
            resolve(true);
          }
        };

        // 現在のconnected状態を一度確認し、すでにtrueならすぐに解決
        myRoleRef.child("connected").once("value").then(snapshot => {
          if (snapshot.val() === true) {
            console.log("[waitForMyConnected] 既にconnected状態がtrueです。");
            resolve(true);
          } else {
            // trueでなければ、リスナーを設定して待機
            myRoleRef.child("connected").on("value", connectedValueListener);
          }
        });
      });
    }


    async function hostRoom() {
      const name = document.getElementById("playerName").value;
      if (!name) return alert("名前を入力してください");

      roomId = Math.random().toString(36).substring(2, 8);
      isHost = true;
      myRoleRef = db.ref("rooms/" + roomId + "/host");
      opponentRoleRef = db.ref("rooms/" + roomId + "/guest");

      // 自分のconnected状態も監視するように設定 (ホスト作成時のみ)
      myConnectedListener = myRoleRef.child("connected").on("value", (snapshot) => {
        console.log(`[My Connected Listener (Host)] 自分のconnected状態: ${snapshot.val()}`);
      });

      try {
        // ルームが存在しないことを確認
        const snapshot = await db.ref("rooms/" + roomId).once("value");
        if (snapshot.exists()) {
          alert("このルームコードはすでに使用されています。もう一度「部屋を作成」を押してください。");
          // myRoleRef のリスナーを解除してリセット
          if (myRoleRef && myConnectedListener) {
            myRoleRef.child("connected").off("value", myConnectedListener);
            myConnectedListener = null;
          }
          myRoleRef = null; // myRoleRef をリセット
          return;
        }

        // ホスト情報を書き込む (connectedはtrueで初期化)
        await myRoleRef.set({
          name: name,
          connected: true // ここで直接trueに設定
        });
        // connectedがtrueになったら、onDisconnectを設定
        await myRoleRef.child('connected').onDisconnect().set(false);
        console.log(`[Host Room] ルーム ${roomId} を作成し、ホスト情報を初期書き込みしました。Connectedをtrueに設定しました。`);

        document.getElementById("menu").style.display = "none";
        document.getElementById("waiting-screen").style.display = "flex";
        document.getElementById("waitingRoomId").innerHTML =
          `ルームコード: <strong>${roomId}</strong> <button onclick="copyRoomCode()">コピー</button>`;

        // 自分のconnected状態がtrueになるまで待つ
        console.log("[Host Room] 自分のconnected状態がtrueになるまで待機中...");
        await waitForMyConnected();
        console.log("[Host Room] 自分のconnected状態がtrueになりました。");

        // ゲストの参加を監視
        opponentConnectedListener = opponentRoleRef.on("value", async (snapshot) => {
          console.log(`[Host Room Listener] ゲストの状態変化:`, snapshot.val());
          console.log(`[Host Room Listener] ゲストが存在するか: ${snapshot.exists()}`);
          console.log(`[Host Room Listener] ゲストのconnected状態: ${snapshot.exists() ? snapshot.val().connected : 'N/A'}`);
          console.log(`[Host Room Listener] ゲームは既に開始されているか: ${gameStarted}`);


          if (snapshot.exists() && snapshot.val().connected === true && !gameStarted) {
            // ゲストが存在し、接続状態が true で、かつゲームがまだ開始されていない場合
            console.log("[Host Room Listener] ゲストが参加し、両者接続済み。ゲーム開始準備。");

            console.log("[Host Room Listener] UIを更新します: wrapperをflexに、waiting-screenをnoneに");
            document.getElementById("wrapper").style.display = "flex";
            document.getElementById("waiting-screen").style.display = "none";
            console.log("[Host Room Listener] startGame()を呼び出します。");
            startGame();
            gameStarted = true;

            // 相手（ゲスト）の接続切断を監視（ゲーム開始後のみ有効）
            // このリスナーは一度だけ設定し、ゲーム終了時に解除する
            opponentRoleRef.child("connected").on("value", (connSnapshot) => {
              const opponentStatus = connSnapshot.val();
              console.log(`[Opponent Connected Listener (Host)] ゲストのconnected状態: ${opponentStatus}`);
              if (gameStarted && (opponentStatus === false || opponentStatus === null)) {
                console.log("[Opponent Connected Listener (Host)] ゲストが切断されました。");
                endGame("相手が退出しました");
              }
            });
            // ゲスト参加リスナーは一度だけ発火すればよいので解除 (後続のconnectedリスナーに任せる)
            opponentRoleRef.off("value", opponentConnectedListener);
          } else if (!snapshot.exists() && gameStarted) {
            // ゲーム開始後にゲストがルームから完全にいなくなった場合
            console.log("[Host Room Listener] ゲーム開始後にゲストデータが消滅しました。");
            endGame("相手が退出しました");
          }
        });

      } catch (error) {
        console.error("ルーム作成エラー:", error);
        alert("ルームの作成に失敗しました。もう一度お試しください。");
        // myRoleRef のリスナーを解除してリセット
        if (myRoleRef && myConnectedListener) {
          myRoleRef.child("connected").off("value", myConnectedListener);
          myConnectedListener = null;
        }
        myRoleRef = null; // myRoleRef をリセット
      }
    }


    async function joinRoom() {
      const name = document.getElementById("playerName").value;
      const code = document.getElementById("roomCode").value;
      if (!name || !code) return alert("名前とルームコードを入力してください");

      roomId = code;
      isHost = false;
      myRoleRef = db.ref("rooms/" + roomId + "/guest");
      opponentRoleRef = db.ref("rooms/" + roomId + "/host");

      // 自分のconnected状態も監視するように設定 (ゲスト参加時のみ)
      myConnectedListener = myRoleRef.child("connected").on("value", (snapshot) => {
        console.log(`[My Connected Listener (Guest)] 自分のconnected状態: ${snapshot.val()}`);
      });

      try {
        const snap = await db.ref("rooms/" + roomId).once("value");
        if (!snap.exists()) {
          alert("そのルームは存在しません");
          // myRoleRef のリスナーを解除してリセット
          if (myRoleRef && myConnectedListener) {
            myRoleRef.child("connected").off("value", myConnectedListener);
            myConnectedListener = null;
          }
          myRoleRef = null; // myRoleRef をリセット
          return;
        }
        if (snap.val().guest) {
          alert("このルームはすでに満員です。");
          // myRoleRef のリスナーを解除してリセット
          if (myRoleRef && myConnectedListener) {
            myRoleRef.child("connected").off("value", myConnectedListener);
            myConnectedListener = null;
          }
          myRoleRef = null; // myRoleRef をリセット
          return;
        }

        // ゲスト情報を書き込む (connectedはtrueで初期化)
        await myRoleRef.set({
          name: name,
          connected: true // ここで直接trueに設定
        });
        // connectedがtrueになったら、onDisconnectを設定
        await myRoleRef.child('connected').onDisconnect().set(false);
        console.log(`[Join Room] ルーム ${roomId} に参加し、ゲスト情報を初期書き込みしました。Connectedをtrueに設定しました。`);


        document.getElementById("menu").style.display = "none";
        document.getElementById("wrapper").style.display = "flex";

        // 自分のconnected状態がtrueになるまで待つ
        console.log("[Join Room] 自分のconnected状態がtrueになるまで待機中...");
        await waitForMyConnected();
        console.log("[Join Room] 自分のconnected状態がtrueになりました。");

        // ホストの接続を監視し、connectedがtrueになるまで待つ
        opponentConnectedListener = opponentRoleRef.on("value", async (snapshot) => {
          console.log(`[Join Room Listener] ホストの状態変化:`, snapshot.val());
          console.log(`[Join Room Listener] ホストが存在するか: ${snapshot.exists()}`);
          console.log(`[Join Room Listener] ホストのconnected状態: ${snapshot.exists() ? snapshot.val().connected : 'N/A'}`);
          console.log(`[Join Room Listener] ゲームは既に開始されているか: ${gameStarted}`);

          if (snapshot.exists() && snapshot.val().connected === true && !gameStarted) {
            // ホストが存在し、接続状態が true で、かつゲームがまだ開始されていない場合
            console.log("[Join Room Listener] ホストが接続済み。両者接続済み。ゲーム開始準備。");

            console.log("[Join Room Listener] UIを更新します: wrapperをflexに、menuをnoneに");
            document.getElementById("menu").style.display = "none";
            document.getElementById("wrapper").style.display = "flex";
            console.log("[Join Room Listener] startGame()を呼び出します。");
            startGame();
            gameStarted = true;

            // 相手（ホスト）の接続切断を監視（ゲーム開始後のみ有効）
            // このリスナーは一度だけ設定し、ゲーム終了時に解除する
            opponentRoleRef.child("connected").on("value", (connSnapshot) => {
              const opponentStatus = connSnapshot.val();
              console.log(`[Opponent Connected Listener (Guest)] ホストのconnected状態: ${opponentStatus}`);
              if (gameStarted && (opponentStatus === false || opponentStatus === null)) {
                console.log("[Opponent Connected Listener (Guest)] ホストが切断されました。");
                endGame("相手が退出しました");
              }
            });
            // ホスト参加リスナーは一度だけ発火すればよいので解除 (後続のconnectedリスナーに任せる)
            opponentRoleRef.off("value", opponentConnectedListener);
          } else if (!snapshot.exists() && gameStarted) {
            // ゲーム開始後にホストがルームから完全にいなくなった場合
            console.log("[Join Room Listener] ゲーム開始後にホストデータが消滅しました。");
            endGame("相手が退出しました");
          } else if (!snapshot.exists() && !gameStarted) {
            // ゲーム開始前にホストが退出した場合は、ルームが存在しないアラートを出す
            console.log("[Join Room Listener] ゲーム開始前にホストが退出しました。");
            alert("ホストが退出したため、ルームに参加できませんでした。");
            location.reload();
          }
        });

      } catch (error) {
        console.error("ルーム参加エラー:", error);
        alert("ルームへの参加に失敗しました。もう一度お試しください。");
        // myRoleRef のリスナーを解除してリセット
        if (myRoleRef && myConnectedListener) {
          myRoleRef.child("connected").off("value", myConnectedListener);
          myConnectedListener = null;
        }
        myRoleRef = null; // myRoleRef をリセット
      }
    }


    function copyRoomCode() {
      navigator.clipboard.writeText(roomId).then(() => {
        alert("ルームコードをコピーしました！");
      }).catch(err => {
        console.error("ルームコードのコピーに失敗しました:", err);
      });
    }

    function setControlMode(mode) {
      controlMode = mode;
      document.getElementById("btn-gesture").classList.toggle("selected", mode === "gesture");
      document.getElementById("btn-button").classList.toggle("selected", mode === "button");
      // ジェスチャーモードでもボタンを表示したいので、attachInputListenersを常に呼び出す
      attachInputListeners();
    }
    const pieceShapes = {
      'T': [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      'O': [
        [1, 1],
        [1, 1]
      ],
      'L': [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
      ],
      'J': [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      'S': [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
      ],
      'Z': [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
      ],
      'I': [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ]
    };

    let nextBag = [];

    function fillBag() {
      const types = 'TJLOSZI'.split('');
      for (let i = types.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [types[i], types[j]] = [types[j], types[i]];
      }
      nextBag = nextBag.concat(types);
    }

    function getNextType() {
      if (nextBag.length < 7) fillBag();
      return nextBag.shift();
    }
    const arena = Array.from({
      length: 20
    }, () => Array(10).fill(0));

    const player = {
      pos: {
        x: 0,
        y: 0
      },
      matrix: null,
      type: '',
      holdUsed: false,
      rotState: 0,
      isTSpin: false // T-Spin判定を追加
    };

    const hold = {
      type: '',
      matrix: null
    };

    function createPiece(type) {
      // PieceShapesが配列の配列なので、ディープコピーして返す
      if (pieceShapes[type]) {
        return pieceShapes[type].map(row => [...row]);
      }
      return null; // 不明なタイプの場合はnullを返す
    }

    function playerReset() {
      const type = getNextType();
      player.type = type;
      player.matrix = createPiece(type);
      player.pos.y = -1; // テトリミノは一番上から落ちてくるので、最初は-1
      player.pos.x = Math.floor((10 - player.matrix[0].length) / 2);
      player.rotState = 0;
      player.holdUsed = false;
      player.isTSpin = false; // 新しいピースなのでT-Spin状態をリセット
      // 初期衝突チェックのコードは削除済み
    }

    function getGhostPosition(p) { // playerオブジェクトを引数にとるように修正
      const ghost = { ...p,
        pos: { ...p.pos
        }
      };
      while (!collide(arena, ghost)) { // 自分のゴーストの場合
        ghost.pos.y++;
      }
      ghost.pos.y--;
      return ghost.pos;
    }

    function getOpponentGhostPosition(p) { // 相手のゴースト用
      if (!p || !p.matrix || !p.pos) return null; // データがない場合はnullを返す
      const ghost = { ...p,
        pos: { ...p.pos
        }
      };
      // 相手のアリーナ(opponentMatrix)に対して衝突判定
      while (!collide(opponentMatrix, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      return ghost.pos;
    }


    function rotate(matrix, dir) {
      // dir > 0 は右回転、dir < 0 は左回転
      const N = matrix.length;
      const result = Array(N).fill(0).map(() => Array(N).fill(0));

      if (dir === 1) { // 右回転
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            result[j][N - 1 - i] = matrix[i][j];
          }
        }
      } else { // 左回転
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            result[N - 1 - j][i] = matrix[i][j];
          }
        }
      }
      return result;
    }


    // SRS Wall Kick data (Standard)
    // [old rotation][new rotation] = [test 1, test 2, test 3, test 4, test 5] offsets [deltaX, deltaY]
    // 0: spawn state (vertical)
    // 1: 90 degree clockwise rotation (right)
    // 2: 180 degree rotation (upside down)
    // 3: 270 degree clockwise rotation (left)
    const wallKickData_JLTSZ = [
      // 0->R (0->1)
      [
        [0, 0],
        [-1, 0],
        [-1, -1],
        [0, 2],
        [-1, 2]
      ],
      // R->0 (1->0)
      [
        [0, 0],
        [1, 0],
        [1, 1],
        [0, -2],
        [1, -2]
      ],
      // R->2 (1->2)
      [
        [0, 0],
        [1, 0],
        [1, 1],
        [0, -2],
        [1, -2]
      ],
      // 2->R (2->1)
      [
        [0, 0],
        [-1, 0],
        [-1, -1],
        [0, 2],
        [-1, 2]
      ],
      // 2->L (2->3)
      [
        [0, 0],
        [1, 0],
        [1, -1],
        [0, 2],
        [1, 2]
      ],
      // L->2 (3->2)
      [
        [0, 0],
        [-1, 0],
        [-1, 1],
        [0, -2],
        [-1, -2]
      ],
      // L->0 (3->0)
      [
        [0, 0],
        [-1, 0],
        [-1, 1],
        [0, -2],
        [-1, -2]
      ],
      // 0->L (0->3)
      [
        [0, 0],
        [1, 0],
        [1, -1],
        [0, 2],
        [1, 2]
      ],
    ];

    const wallKickData_I = [
      // 0->R (0->1)
      [
        [0, 0],
        [-2, 0],
        [1, 0],
        [-2, 1],
        [1, -2]
      ],
      // R->0 (1->0)
      [
        [0, 0],
        [2, 0],
        [-1, 0],
        [2, -1],
        [-1, 2]
      ],
      // R->2 (1->2)
      [
        [0, 0],
        [-1, 0],
        [2, 0],
        [-1, -2],
        [2, 1]
      ],
      // 2->R (2->1)
      [
        [0, 0],
        [1, 0],
        [-2, 0],
        [1, 2],
        [-2, -1]
      ],
      // 2->L (2->3)
      [
        [0, 0],
        [2, 0],
        [-1, 0],
        [2, -1],
        [-1, 2]
      ],
      // L->2 (3->2)
      [
        [0, 0],
        [-2, 0],
        [1, 0],
        [-2, 1],
        [1, -2]
      ],
      // L->0 (3->0)
      [
        [0, 0],
        [1, 0],
        [-2, 0],
        [1, 2],
        [-2, -1]
      ],
      // 0->L (0->3)
      [
        [0, 0],
        [-1, 0],
        [2, 0],
        [-1, -2],
        [2, 1]
      ],
    ];


    function playerRotate(dir) {
      const oldMatrix = player.matrix;
      const oldPos = { ...player.pos
      }; // 現在の位置を保存
      const oldRotState = player.rotState; // 現在の回転状態を保存

      const rotated = rotate(player.matrix, dir);
      let newRotState = (player.rotState + (dir === 1 ? 1 : 3)) % 4; // dir=1(右回転), dir=-1(左回転)

      const pieceType = player.type;
      const kickTable = (pieceType === 'I') ? wallKickData_I : wallKickData_JLTSZ;

      let testIndex;
      if (dir === 1) { // 右回転 (0->1, 1->2, 2->3, 3->0)
        testIndex = oldRotState * 2;
      } else { // 左回転 (0->3, 1->0, 2->1, 3->2)
        // 左回転の場合の正しいインデックスマッピング
        // 0(Spawn) -> 3(Left): 7
        // 1(Right) -> 0(Spawn): 1
        // 2(Down)  -> 1(Right): 3
        // 3(Left)  -> 2(Down):  5
        if (oldRotState === 0 && newRotState === 3) testIndex = 7;
        else if (oldRotState === 1 && newRotState === 0) testIndex = 1;
        else if (oldRotState === 2 && newRotState === 1) testIndex = 3;
        else if (oldRotState === 3 && newRotState === 2) testIndex = 5;
      }

      const tests = kickTable[testIndex];
      // console.log(`Piece: ${pieceType}, Old State: ${oldRotState}, New State: ${newRotState}, Dir: ${dir}, Test Index: ${testIndex}`);

      player.isTSpin = false; // 回転前にT-Spin状態をリセット

      for (let i = 0; i < tests.length; i++) {
        const [ox, oy] = tests[i];
        player.matrix = rotated;
        player.pos.x = oldPos.x + ox; // 保存した元の位置にオフセットを適用
        player.pos.y = oldPos.y - oy; // Y軸はTRSでは上方向が正、テトリスでは下方向が正なので符号反転

        if (!collide(arena, player)) {
          player.rotState = newRotState;

          // T-Spin判定ロジック
          if (player.type === 'T') {
            // Tミノの回転中心周りの4つの角のうち、3つ以上が埋まっているかチェック
            // Tミノの回転中心は matrix[1][1] (0-indexed)
            // 各回転状態でのTミノの角の相対座標 (時計回り)
            const tCorners = [
              [
                [-1, -1],
                [1, -1],
                [-1, 1],
                [1, 1]
              ], // 0 (Spawn)
              [
                [1, -1],
                [1, 1],
                [-1, -1],
                [-1, 1]
              ], // 1 (Right)
              [
                [1, 1],
                [-1, 1],
                [1, -1],
                [-1, -1]
              ], // 2 (Down)
              [
                [-1, 1],
                [-1, -1],
                [1, 1],
                [1, -1]
              ] // 3 (Left)
            ];

            let filledCorners = 0;
            const currentCorners = tCorners[player.rotState];

            for (const [relX, relY] of currentCorners) {
              const checkX = player.pos.x + 1 + relX; // Tミノの回転中心は (1,1)
              const checkY = player.pos.y + 1 + relY;

              // 盤面内かつブロックが存在するか
              if (checkY >= 0 && checkY < 20 && checkX >= 0 && checkX < 10 && arena[checkY][checkX] !== 0) {
                filledCorners++;
              } else if (checkY < 0 || checkY >= 20 || checkX < 0 || checkX >= 10) {
                // 盤面外でも「壁」としてカウント (端にいる場合)
                filledCorners++;
              }
            }
            if (filledCorners >= 3) {
              player.isTSpin = true;
            }
          }
          sendMatrix(); // ★ 回転後にも位置情報を送信
          return;
        }
      }
      // 全てのテストに失敗した場合、元の状態に戻す
      player.matrix = oldMatrix;
      player.pos = oldPos;
      player.rotState = oldRotState;
    }


    function holdPiece() {
      if (player.holdUsed) return;
      const temp = player.type;
      if (!hold.type) {
        hold.type = temp;
        playerReset();
      } else {
        player.type = hold.type;
        player.matrix = createPiece(hold.type);
        hold.type = temp;
      }
      hold.matrix = createPiece(hold.type);
      player.pos.y = -1;
      player.pos.x = Math.floor((10 - player.matrix[0].length) / 2);
      player.holdUsed = true;
      sendMatrix(); // ★ ホールド後にも位置情報を送信
    }

    let combo = -1;
    let lastClearWasSpecial = false; // T-Spinまたはテトリスが連続しているか判定するため

    function playerMove(dir) {
      player.pos.x += dir;
      if (collide(arena, player)) {
        player.pos.x -= dir;
      }
      sendMatrix(); // ★ 移動後にも位置情報を送信
    }

    function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);

        const cleared = sweep();
        if (cleared > 0) {
          combo++;
          attackQueue += calculateAttack(cleared, combo, player.isTSpin, player.type, player.rotState); // player.typeとplayer.rotStateを追加
        } else {
          combo = -1;
          lastClearWasSpecial = false; // コンボが途切れたらB2Bもリセット
        }

        playerReset();
        sendMatrix();
        checkLose();
        // ここに攻撃ライン送信ロジックを追加
        if (attackQueue > 0) {
          sendAttack(attackQueue);
          attackQueue = 0; // 送信後リセット
        }
      }
      sendMatrix(); // ★ 落下後にも位置情報を送信 (重要: 毎フレームの更新)
      dropCounter = 0;
    }

    function hardDrop() {
      while (!collide(arena, player)) {
        player.pos.y++;
      }
      player.pos.y--;
      fixPiece();
    }

    function fixPiece() {
      merge(arena, player);
      const lines = sweep();
      if (lines > 0) {
        combo++;
        attackQueue += calculateAttack(lines, combo, player.isTSpin, player.type, player.rotState); // player.typeとplayer.rotStateを追加
      } else {
        combo = -1;
        lastClearWasSpecial = false; // コンボが途切れたらB2Bもリセット
      }
      playerReset();
      sendMatrix(); // ★ ピース固定後にも位置情報を送信
      checkLose();
      // ここに攻撃ライン送信ロジックを追加
      if (attackQueue > 0) {
        sendAttack(attackQueue);
        attackQueue = 0; // 送信後リセット
      }
    }

    function merge(arena, player) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + player.pos.y][x + player.pos.x] = value;
          }
        });
      });
    }

    function sweep() {
      let lines = 0;
      outer: for (let y = arena.length - 1; y >= 0; y--) {
        for (let x = 0; x < arena[y].length; x++) {
          if (arena[y][x] === 0) continue outer;
        }
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        lines++;
        y++;
      }
      return lines;
    }

    // ★ 修正点: calculateAttack 関数に playerType と playerRotState を追加
    function calculateAttack(lines, combo, isTSpin, playerType, playerRotState) {
      let attack = 0;
      let currentClearIsSpecial = false;

      if (isTSpin) {
        if (lines === 1) attack = 2; // T-Spin Single
        else if (lines === 2) attack = 4; // T-Spin Double
        else if (lines === 3) attack = 6; // T-Spin Triple
        currentClearIsSpecial = true;
      } else {
        if (lines === 1) attack = 0; // Single
        else if (lines === 2) attack = 1; // Double
        else if (lines === 3) attack = 2; // Triple
        else if (lines === 4) { // Tetris
          attack = 4;
          currentClearIsSpecial = true;

          // ★ Iミノボーナス判定
          if (playerType === 'I' && (playerRotState === 1 || playerRotState === 3)) { // 垂直なIミノ (回転状態1または3)
            console.log("Iミノボーナス！");
            attack += 1; // Puyo Puyo Tetrisでは+1ライン
          }
        }
      }

      // Back-to-Back ボーナス
      if (currentClearIsSpecial && lastClearWasSpecial) {
        attack = Math.floor(attack * 1.5); // B2Bボーナス (1.5倍、端数切り捨て)
      }
      lastClearWasSpecial = currentClearIsSpecial; // 状態を更新

      // Comboボーナス
      if (combo > 0) attack += Math.floor(combo / 2);

      return attack;
    }

    function drawMatrix(ctx, matrix, offset, type = 1) {
      const color = getColor(type);
      if (!matrix) return; // matrixがnullの場合の安全策
      matrix.forEach((row, y) => {
        if (!row) return; // rowがnullの場合の安全策
        row.forEach((val, x) => {
          if (val !== 0) {
            ctx.fillStyle = color;
            ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
            ctx.strokeStyle = '#a0e0ff';
            ctx.lineWidth = 0.05;
            ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
          }
        });
      });
    }

    let attackQueue = 0;

    function sendAttack(lines) {
      if (roomId) {
        const path = isHost ? "guest" : "host"; // ホストはゲストに、ゲストはホストに送る
        db.ref(`rooms/${roomId}/${path}/attack`).transaction(currentAttack => {
          return (currentAttack || 0) + lines;
        });
      }
    }

    function drawOpponent() {
      const canvas = document.getElementById("opponent");
      const ctx = canvas.getContext("2d");
      ctx.setTransform(1, 0, 0, 1, 0, 0); // クリア前にスケールをリセット
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.scale(20, 20); // スケールを設定

      // 相手の積まれた盤面を描画
      for (let y = 0; y < opponentMatrix.length; y++) {
        for (let x = 0; x < opponentMatrix[y].length; x++) {
          const val = opponentMatrix[y][x];
          if (val !== 0) {
            ctx.fillStyle = getColor(val);
            ctx.fillRect(x, y, 1, 1);
            ctx.strokeStyle = '#a0e0ff';
            ctx.lineWidth = 0.05;
            ctx.strokeRect(x, y, 1, 1);
          }
        }
      }

      // 相手の落ちているテトリミノを描画
      if (opponentPlayerType && opponentPlayerPosition) {
        const opponentPlayerMatrix = createPiece(opponentPlayerType);
        if (opponentPlayerMatrix) { // createPieceがnullを返す可能性があるのでチェック
          const ghostPos = getOpponentGhostPosition({
            matrix: opponentPlayerMatrix,
            pos: opponentPlayerPosition
          });
          if (ghostPos) {
            drawMatrix(ctx, opponentPlayerMatrix, ghostPos, 'ghost'); // ゴーストピース
          }
          // 落ちているピースを描画する際、y座標が0以上の部分だけを描画
          opponentPlayerMatrix.forEach((row, y) => {
            row.forEach((value, x) => {
              const drawY = y + opponentPlayerPosition.y;
              const drawX = x + opponentPlayerPosition.x;
              // ★ 修正点: value !== 0 && drawY >= 0 の両方の条件を満たす場合のみ描画
              if (value !== 0 && drawY >= 0) {
                ctx.fillStyle = getColor(opponentPlayerType); // ピースのタイプで色を取得
                ctx.fillRect(drawX, drawY, 1, 1);
                ctx.strokeStyle = '#a0e0ff';
                ctx.lineWidth = 0.05;
                ctx.strokeRect(drawX, drawY, 1, 1);
              }
            });
          });
        }
      }
    }

    function drawGarbageIndicator() {
      const canvas = document.getElementById("garbage-indicator");
      const ctx = canvas.getContext("2d");
      ctx.setTransform(1, 0, 0, 1, 0, 0); // クリア前にスケールをリセット
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cellHeight = 20;
      for (let i = 0; i < incomingGarbage; i++) {
        ctx.fillStyle = "#888";
        ctx.fillRect(0, canvas.height - (i + 1) * cellHeight, canvas.width, cellHeight);
      }
    }

    function applyGarbage(lines) {
      for (let i = 0; i < lines; i++) {
        arena.shift();
        const garbage = Array(10).fill(8);
        const hole = Math.floor(Math.random() * 10);
        garbage[hole] = 0;
        arena.push(garbage);
      }
      checkLose();
    }

    function listenAttackLines() {
      if (roomId) {
        const path = isHost ? "host" : "guest"; // 自分がおじゃまラインを受け取るパス
        db.ref(`rooms/${roomId}/${path}/attack`).on("value", snapshot => {
          const lines = snapshot.val();
          console.log(`[Attack Listener] 相手からの攻撃ライン: ${lines}`);
          if (lines && Number.isInteger(lines) && lines > 0) {
            incomingGarbage = lines;
            setTimeout(() => {
              applyGarbage(lines);
              incomingGarbage = 0;
            }, 500);
            // おじゃまラインを受け取ったら、相手の攻撃ラインを0にリセットする
            // これにより、同じおじゃまラインを繰り返し受け取らないようにします
            const opponentPath = isHost ? "guest" : "host"; // 相手のパス
            db.ref(`rooms/${roomId}/${opponentPath}/attack`).set(0);
          }
        });
      }
    }

    function getColor(type) {
      const colors = {
        'I': '#66CCFF',
        'O': '#FFCC66',
        'T': '#CC66FF',
        'S': '#66FF66',
        'Z': '#FF6666',
        'J': '#6666FF',
        'L': '#FF9966',
        8: 'gray', // garbage line
        'ghost': 'rgba(128,128,128,0.4)', // ゴーストピースの色
        'default': '#555' // デフォルト色を追加
      };
      // typeが配列の場合（drawMatrixで直接matrixが渡された場合）は、最初の非ゼロ値を使う
      if (Array.isArray(type)) {
        for (let r of type) {
          for (let v of r) {
            if (v !== 0) return colors[v] || colors['default']; // その値の色を返す
          }
          break; // 最初の行をチェックしたら終了
        }
        return colors['default']; // 全て0の場合はデフォルト色
      }
      // typeが文字列の場合（'I','T'など）はそのまま色を返す
      return colors[type] || colors[type.toString()] || '#888';
    }

    function checkLose() {
      console.log("[Check Lose] Checking for lose condition.");
      // ピースの生成位置が-1なので、arena[0]やarena[1]ではなく、ピースのY座標+1で判定
      // 最上段にピースが来てしまったら負け
      if (collide(arena, player) && player.pos.y <= 0) {
        console.log("[Check Lose] Lose condition met! Top rows are occupied.");
        endGame("あなたの負けです");
        return true;
      }
      console.log("[Check Lose] No lose condition detected.");
      return false;
    }


    function endGame(message) {
      console.log(`[End Game] ゲーム終了処理開始。メッセージ: "${message}"`);
      // ゲームがまだ開始されていない状態で「相手が退出」のメッセージが来た場合は重複処理を避ける
      if (!gameStarted && (message === "相手が退出しました" || message === "ホストが退出したため、ルームに参加できませんでした。")) {
        console.log("[End Game] ゲームは既に終了しているか、早期退出検知。処理をスキップ。");
        // ただし、リロードは実行する
        setTimeout(() => {
          location.reload();
        }, 500);
        return;
      }

      gameStarted = false;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (softDropInterval) {
        clearInterval(softDropInterval);
        softDropInterval = null;
      }

      // 自分の `connected` 状態を `false` に設定し、onDisconnectもキャンセル
      if (myRoleRef) {
        myRoleRef.child("connected").onDisconnect().cancel()
          .then(() => {
            console.log(`[End Game] 自分のonDisconnect設定をキャンセルしました。`);
            return myRoleRef.child("connected").set(false);
          })
          .then(() => console.log(`[End Game] 自分のconnected状態をfalseに更新しました。`))
          .catch(error => console.error(`[End Game] connected状態の更新に失敗しました:`, error));
      }

      // Firebaseのリスナーを全て解除
      if (roomId) {
        // 自分のconnected状態リスナーを解除
        if (myRoleRef && myConnectedListener) {
          myRoleRef.child("connected").off("value", myConnectedListener);
          myConnectedListener = null;
          console.log("[End Game] 自分のconnectedリスナーを解除しました。");
        }
        // 相手のconnected状態を監視するリスナーを解除 (相手の参照が設定されていれば)
        if (opponentRoleRef && opponentConnectedListener) {
          opponentRoleRef.child("connected").off("value", opponentConnectedListener);
          opponentConnectedListener = null;
          console.log("[End Game] 相手のconnectedリスナーを解除しました。");
        }
        // 攻撃ラインリスナーと相手の盤面リスナーを解除
        if (opponentRoleRef) {
          opponentRoleRef.child("attack").off();
          opponentRoleRef.child("gameData").off();
          console.log("[End Game] 相手のattack/gameDataリスナーを解除しました。");
        }
      }

      alert(message);

      // ホストのみがルームを削除する。ゲーム終了が「あなたの負け」の場合のみ。
      if (isHost && roomId && message === "あなたの負けです") {
        db.ref("rooms/" + roomId).remove()
          .then(() => console.log("Host removed room successfully."))
          .catch(error => console.error("Error removing room:", error));
      } else if (!isHost && roomId && (message === "相手が退出しました" || message === "あなたの負けです")) {
        // ゲストの場合、自分のデータのみ削除（ホストがルームを削除しない限りルームは残る）
        if (myRoleRef) {
          myRoleRef.remove()
            .then(() => console.log("Guest removed own data successfully."))
            .catch(error => console.error("Error removing guest data:", error));
        }
      }

      setTimeout(() => {
        location.reload();
      }, 500);
    }

    function startGame() {
      console.log("[Start Game] ゲーム開始処理。");
      gameStarted = true;

      // 盤面を初期化
      for (let y = 0; y < arena.length; y++) {
        for (let x = 0; x < arena[y].length; x++) {
          arena[y][x] = 0;
        }
      }

      // ★ 修正点: 初期化順序を調整
      fillBag(); // Nextキューの初期化
      playerReset(); // 最初のピースを生成
      sendMatrix(); // 初期状態をFirebaseに送信（nextBag[0]も送信されるように）

      dropCounter = 0;
      lastTime = 0;
      animationFrameId = requestAnimationFrame(update); // ここでゲームループ開始
      console.log("[Start Game] ゲームループを開始しました。");

      listenOpponentMatrix();
      listenAttackLines();
      attachInputListeners(); // ゲーム開始後に改めてリスナーを設定
      console.log("[Start Game] 相手のデータリスナーと入力リスナーを設定しました。");
    }

    function update(time = 0) {
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;

      if (dropCounter > dropInterval) {
        playerDrop();
      }

      draw();
      animationFrameId = requestAnimationFrame(update);
    }

    function draw() {
      const ctx = document.getElementById('tetris').getContext('2d');
      ctx.setTransform(1, 0, 0, 1, 0, 0); // 全てのリセットとクリアを最初に行う
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.scale(20, 20);

      drawMatrix(ctx, arena, {
        x: 0,
        y: 0
      });

      const ghostPos = getGhostPosition(player);
      drawMatrix(ctx, player.matrix, ghostPos, 'ghost');

      drawMatrix(ctx, player.matrix, player.pos, player.type);

      // --- 自分のNextピースの描画 ---
      const nextCtx = document.getElementById('next').getContext('2d');
      nextCtx.setTransform(1, 0, 0, 1, 0, 0);
      nextCtx.clearRect(0, 0, nextCtx.canvas.width, nextCtx.canvas.height);
      nextCtx.scale(20, 20);

      const displayNextCount = Math.min(nextBag.length, 3); // 最大3つのNextピースを表示
      for (let i = 0; i < displayNextCount; i++) {
        // ★ 修正点: nextBag[i] の存在確認を追加
        if (!nextBag[i]) continue;

        const nextMatrix = createPiece(nextBag[i]);
        if (nextMatrix) { // nullチェック
          const xOffset = Math.floor((4 - nextMatrix[0].length) / 2); // 4マス幅のNext表示領域を想定
          const yOffset = 1 + i * 5; // 各ピースが5マス分の空間を占めるように配置 (高さ最大4 + 1マス間隔)

          drawMatrix(nextCtx, nextMatrix, {
            x: xOffset,
            y: yOffset
          }, nextBag[i]);
        }
      }


      // --- 自分のHoldピースの描画 ---
      const holdCtx = document.getElementById('hold').getContext('2d');
      holdCtx.setTransform(1, 0, 0, 1, 0, 0);
      holdCtx.clearRect(0, 0, holdCtx.canvas.width, holdCtx.canvas.height);
      holdCtx.scale(20, 20);
      if (hold.type) {
        const holdMatrix = createPiece(hold.type);
        if (holdMatrix) { // nullチェック
          const xOffset = Math.floor((4 - holdMatrix[0].length) / 2);
          const yOffset = Math.floor((4 - holdMatrix.length) / 2); // Hold領域の中心に表示
          drawMatrix(holdCtx, holdMatrix, {
            x: xOffset,
            y: yOffset
          }, hold.type);
        }
      }

      // --- 相手のNextピースの描画 ---
      const opponentNextCtx = document.getElementById('opponentNext').getContext('2d');
      opponentNextCtx.setTransform(1, 0, 0, 1, 0, 0);
      opponentNextCtx.clearRect(0, 0, opponentNextCtx.canvas.width, opponentNextCtx.canvas.height);
      opponentNextCtx.scale(20, 20);
      // ★ 修正点: 相手のNextピースを複数描画 (最大2つ)
      const displayOpponentNextCount = Math.min(opponentNextPieces.length, 2); // 相手のNextピースを2つ表示
      for (let i = 0; i < displayOpponentNextCount; i++) {
        if (!opponentNextPieces[i]) continue; // null/undefined 保護

        const opponentNextMatrix = createPiece(opponentNextPieces[i]);
        if (opponentNextMatrix) { // nullチェック
          const xOffset = Math.floor((4 - opponentNextMatrix[0].length) / 2);
          const yOffset = 1 + i * 5; // 自分のNextピースと同様に縦に並べる
          drawMatrix(opponentNextCtx, opponentNextMatrix, {
            x: xOffset,
            y: yOffset
          }, opponentNextPieces[i]);
        }
      }


      // --- 相手のHoldピースの描画 ---
      const opponentHoldCtx = document.getElementById('opponentHold').getContext('2d');
      opponentHoldCtx.setTransform(1, 0, 0, 1, 0, 0);
      opponentHoldCtx.clearRect(0, 0, opponentHoldCtx.canvas.width, opponentHoldCtx.canvas.height);
      opponentHoldCtx.scale(20, 20);
      if (opponentHoldPiece) {
        const opponentHoldMatrix = createPiece(opponentHoldPiece);
        if (opponentHoldMatrix) { // nullチェック
          const xOffset = Math.floor((4 - opponentHoldMatrix[0].length) / 2);
          const yOffset = Math.floor((4 - opponentHoldMatrix.length) / 2); // Hold領域の中心に表示
          drawMatrix(opponentHoldCtx, opponentHoldMatrix, {
            x: xOffset,
            y: yOffset
          }, opponentHoldPiece);
        }
      }


      drawOpponent(); // 相手盤面・テトリミノの描画
      drawGarbageIndicator();
    }

    // 衝突判定
    function collide(targetArena, p) { // targetArenaを引数で受け取るように変更
      const [m, o] = [p.matrix, p.pos];
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
          if (m[y][x] !== 0) {
            // 盤面外との衝突判定
            if (x + o.x < 0 || x + o.x >= 10 || y + o.y >= 20) {
              return true;
            }
            // 積まれたブロックとの衝突判定
            if (y + o.y >= 0 && targetArena[y + o.y] && targetArena[y + o.y][x + o.x] !== 0) {
              return true;
            }
          }
        }
      }
      return false;
    }


    function sendMatrix() {
      if (roomId && myRoleRef) {
        // ★ 修正点: nextPieces を配列として送信する
        const nextPiecesToSend = [];
        for (let i = 0; i < Math.min(nextBag.length, 2); i++) { // 次の2つまで送信
          nextPiecesToSend.push(nextBag[i]);
        }

        myRoleRef.child("gameData").set({
          arena: arena,
          playerType: player.type,
          playerPosition: player.pos, // ここで player.pos が送信される
          nextPieces: nextPiecesToSend.length > 0 ? nextPiecesToSend : [], // nextPieceをnextPiecesに変更（配列）
          holdPiece: hold.type
        });
      }
    }

    function listenOpponentMatrix() {
      if (opponentRoleRef) {
        opponentRoleRef.child("gameData").on("value", snapshot => {
          const gameData = snapshot.val();
          if (gameData) {
            console.log("[Opponent Matrix Listener] 相手のゲームデータを受信しました:", gameData);
            opponentMatrix = gameData.arena || Array.from({
              length: 20
            }, () => Array(10).fill(0));

            opponentPlayerType = gameData.playerType;
            opponentPlayerPosition = gameData.playerPosition;
            // ★ 修正点: nextPieceをnextPiecesとして受け取る
            opponentNextPieces = gameData.nextPieces || []; // 配列として受け取る
            opponentHoldPiece = gameData.holdPiece;

            draw();
            console.log("[Opponent Matrix Listener] 相手の盤面を更新しました。");
          } else {
            console.log("[Opponent Matrix Listener] 相手のゲームデータは空です。");
            opponentPlayerType = null;
            opponentPlayerPosition = null;
            opponentNextPieces = []; // 配列として初期化
            opponentHoldPiece = null;
            draw();
          }
        });
      }
    }

    function startSoftDrop() {
      if (dropInterval !== 50) {
        dropInterval = 50;
      }
    }

    function stopSoftDrop() {
      dropInterval = 1000;
    }

    function attachInputListeners() {
      canvas.removeEventListener("touchstart", handleTouchStart);
      canvas.removeEventListener("touchend", handleTouchEnd);

      const touchControls = document.getElementById("touch-controls");

      if (gameStarted) {
        // gameStartedがtrueであれば、常にボタンを表示
        touchControls.style.display = "grid";

        // controlModeに応じてタッチイベントリスナーを設定
        if (controlMode === "gesture") {
          // ジェスチャーモードの場合、canvasにタッチイベントリスナーを設定
          canvas.addEventListener("touchstart", handleTouchStart);
          canvas.addEventListener("touchend", handleTouchEnd);
        } else {
          // ボタンモードの場合、canvasのタッチイベントリスナーを削除
          canvas.removeEventListener("touchstart", handleTouchStart);
          canvas.removeEventListener("touchend", handleTouchEnd);
        }
      } else {
        // ゲームが開始されていない場合、ボタンを非表示にし、canvasのリスナーも削除
        touchControls.style.display = "none";
        canvas.removeEventListener("touchstart", handleTouchStart);
        canvas.removeEventListener("touchend", handleTouchEnd);
      }
    }

    function handleTouchStart(e) {
      if (!gameStarted) return;
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    }

    function handleTouchEnd(e) {
      if (!gameStarted) return;
      const touch = e.changedTouches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > swipeThreshold) playerMove(1);
        else if (dx < -swipeThreshold) playerMove(-1);
      } else {
        if (dy > swipeThreshold) playerDrop(); // 下スワイプはソフトドロップ
        else if (dy < -swipeThreshold) hardDrop(); // 上スワイプはハードドロップ
      }

      // タップ判定 (スワイプ閾値未満の移動)
      if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
        // canvasの左半分をタップしたら左回転、右半分をタップしたら右回転
        if (touch.clientX < canvas.getBoundingClientRect().left + canvas.width / 2) playerRotate(-1);
        else playerRotate(1);
      }
    }

    attachInputListeners(); // 初期ロード時にも呼び出す
  </script>
</body>

</html>
