あ

<?php
// Your code here!

?>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>テトリス</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            background: #d0f0ff;
            font-family: sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        #wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 10px;
            box-sizing: border-box;
        }
        canvas {
            background: #ffffff;
            border: 4px solid #a0e0ff;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            margin: 5px;
        }
        #game-container {
            position: relative;
        }
        #tetris {
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui {
            display: grid;
            /* NEW GRID LAYOUT: 左回転 ↑ 右回転, ← →, ↓, HOLD */
            grid-template-areas:
                "rotL hard rotR" /* 左回転, ハードドロップ, 右回転 */
                "left .    right" /* 左, 中央空き, 右 */
                ".    down ."   /* 中央空き, ソフトドロップ, 中央空き */
                "hold hold hold"; /* ホールドボタンが中央下部に横並び */
            grid-template-columns: 1fr 1fr 1fr; /* 3列 */
            gap: 10px;
            margin-top: 20px;
            padding: 0 10px;
            width: 100%;
            max-width: 400px; /* Adjust max-width if needed for better button sizing */
        }
        .btn {
            padding: 15px 0;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            background: #a0e0ff;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            touch-action: manipulation;
            width: 100%;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        .btn-left { grid-area: left; }
        .btn-right { grid-area: right; }
        .btn-rotate-left { grid-area: rotL; }
        .btn-rotate-right { grid-area: rotR; }
        .btn-down { grid-area: down; }
        .btn-hard-drop { grid-area: hard; }
        .btn-hold { grid-area: hold; } /* HOLDボタンは横3マスを占有 */


        .info {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            align-items: flex-start;
        }
        .info > div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #score {
            margin: 10px;
            font-size: 20px;
            font-weight: bold;
        }
        /* Modal Overlay */
        #overlay, #ranking-overlay, #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Modal Content */
        #mode-selection-modal, #ranking-modal, #game-over-modal {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90%;
            width: 350px;
        }

        #mode-selection-modal h2, #ranking-modal h2, #game-over-modal h2 {
            margin-top: 0;
            color: #333;
        }
        #game-over-modal p {
            font-size: 1.2em;
            margin: 10px 0;
        }


        #mode-selection-modal button, #ranking-modal button, #game-over-modal button {
            display: block;
            width: 80%;
            padding: 15px;
            margin: 15px auto;
            font-size: 20px;
            border: none;
            border-radius: 8px;
            background: #a0e0ff;
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: background 0.3s ease;
        }

        #mode-selection-modal button:hover, #ranking-modal button:hover, #game-over-modal button:hover {
            background: #80cfff;
        }

        #ranking-modal ol {
            list-style: decimal;
            padding: 0;
            margin: 0;
            text-align: left;
        }

        #ranking-modal li {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1em;
        }

        #ranking-modal li:last-child {
            border-bottom: none;
        }

        #ranking-modal .pagination {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        #ranking-modal .pagination button {
            width: 48%;
            padding: 10px;
            font-size: 16px;
            margin: 0;
        }
    </style>
</head>
<body>
    <h1>テトリス</h1>
    <div id="score">スコア: 0</div>
    <div id="wrapper">
        <div class="info">
            <div>
                <p>NEXT</p>
                <canvas id="next" width="80" height="240"></canvas>
            </div>
            <div id="game-container">
                <canvas id="tetris" width="240" height="400"></canvas>
            </div>
            <div>
                <p>HOLD</p>
                <canvas id="hold" width="80" height="80"></canvas>
            </div>
        </div>
        <div id="ui">
            <button class="btn btn-rotate-left" onclick="playerRotate(false)">左回転</button>
            <button class="btn btn-hard-drop" onclick="hardDrop()">↑</button>
            <button class="btn btn-rotate-right" onclick="playerRotate(true)">右回転</button>
            <button class="btn btn-left" onclick="playerMove(-1)">←</button>
            <button class="btn btn-right" onclick="playerMove(1)">→</button>
            <button class="btn btn-down" onmousedown="startSoftDrop()" onmouseup="stopSoftDrop()" onmouseleave="stopSoftDrop()" ontouchstart="startSoftDrop()" ontouchend="stopSoftDrop()">↓</button>
            <button class="btn btn-hold" onclick="holdPiece()">HOLD</button>
            </div>
    </div>

    <div id="overlay">
        <div id="mode-selection-modal">
            <h2>テトリス</h2>
            <button id="btn-mode-button">ボタン操作</button>
            <button id="btn-mode-gesture">タッチジェスチャー</button>
            <button id="btn-show-ranking" onclick="showRankingModal()">ランキング表示</button>
        </div>
    </div>

    <div id="ranking-overlay" style="display: none;">
        <div id="ranking-modal">
            <h2>ランキング</h2>
            <ol id="ranking-list"></ol>
            <div class="pagination">
                <button id="prev-page-btn" disabled>前のページ</button>
                <button id="next-page-btn" disabled>次のページ</button>
            </div>
            <button onclick="hideRankingModal()">閉じる</button>
        </div>
    </div>

    <div id="game-over-overlay" style="display: none;">
        <div id="game-over-modal">
            <h2>ゲームオーバー！</h2>
            <p id="final-score-display"></p>
            <p id="lines-cleared-display"></p>
            <button onclick="registerRanking()">ランキングを登録</button>
            <button onclick="hideGameOverModalAndShowMenu()">メニューに戻る</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAiWLR5xBKMpKEYdGUL2mL7HVY2LWAbwX0",
            authDomain: "donguri-tetris-8a263.firebaseapp.com",
            projectId: "donguri-tetris-8a263",
            storageBucket: "donguri-tetris-8a263.firebaseastorage.app",
            messagingSenderId: "483465796703",
            appId: "1:483465796703:web:9c8d4a06a1c4c2be13cfea"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        context.scale(20, 20); // 1マス20x20ピクセル

        const nextCanvas = document.getElementById('next');
        const nextCtx = nextCanvas.getContext('2d');
        nextCtx.scale(20, 20); // 1マス20x20ピクセル (nextが3つ表示されるので高さは3*4=12マス分必要)

        const holdCanvas = document.getElementById('hold');
        const holdCtx = holdCanvas.getContext('2d');
        holdCtx.scale(20, 20); // 1マス20x20ピクセル

        let score = 0;
        let linesCleared = 0; // 消したライン数を追跡
        let combo = -1; // 連鎖数を追跡 (初回消去で0連鎖)
        // let lastRotationType = null; // 最後の回転が通常回転かT-Spinか

        const scoreElem = document.getElementById('score');

        const colors = {
            'I': '#66CCFF', // 水色
            'O': '#FFCC66', // オレンジがかった黄色
            'T': '#CC66FF', // 紫
            'S': '#66FF66', // 緑
            'Z': '#FF6666', // 赤
            'J': '#6666FF', // 青
            'L': '#FF9966', // オレンジ
            'ghost': 'rgba(128, 128, 128, 0.4)', // ゴーストピース (半透明グレー、背景色に馴染むように調整)
            'border': '#a0e0ff', // border色
        };

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) matrix.push(new Array(w).fill(0));
            return matrix;
        }

        function drawMatrix(matrix, offset, ctx, type, alpha = 1) {
            const baseColor = (type === 'ghost') ? colors['ghost'] : colors[type];

            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = baseColor;
                        ctx.globalAlpha = alpha;
                        ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.strokeStyle = colors['border'];
                        ctx.lineWidth = 0.03;
                        ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.globalAlpha = 1;
                    }
                });
            });
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = player.type;
                    }
                });
            });
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                        ((arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0 ||
                        y + o.y >= arena.length ||
                        x + o.x < 0 || x + o.x >= arena[0].length)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function rotate(matrix, rightRotate = true) {
            const newMatrix = createMatrix(matrix.length, matrix[0].length);
            if (rightRotate) {
                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix[y].length; x++) {
                        newMatrix[x][matrix.length - 1 - y] = matrix[y][x];
                    }
                }
            } else {
                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix[y].length; x++) {
                        newMatrix[matrix[y].length - 1 - x][y] = matrix[y][x];
                    }
                }
            }
            return newMatrix;
        }

        // T-Spin判定ヘルパー関数
        function checkTSpin(originalPos, newPos, currentMatrix) {
            // TミノでなければT-Spinではない
            if (player.type !== 'T') return false;

            // 回転前後の位置が同じ（壁蹴りしていない）場合はT-Spinではない可能性が高い
            // ただし、完全に同じ位置でもT-Spinになるケース（T-Spin Doubleのセットアップなど）はある
            // ここでは簡易的な判定として、移動がなかった場合はT-Spinではないとする
            if (originalPos.x === newPos.x && originalPos.y === newPos.y) {
                 return false; // 回転後に全く位置が動かない場合はT-Spinでないとする
            }

            // Tミノの回転軸の周囲の角セル座標 (3x3のバウンディングボックス基準)
            // Tミノの中心を (px + 1, py + 1) と仮定
            const testOffsets = [
                {dx: 0, dy: 0}, // Top-Left
                {dx: 2, dy: 0}, // Top-Right
                {dx: 0, dy: 2}, // Bottom-Left
                {dx: 2, dy: 2}  // Bottom-Right
            ];

            let blockedCorners = 0;
            for (const offset of testOffsets) {
                const checkX = player.pos.x + offset.dx;
                const checkY = player.pos.y + offset.dy;

                // 範囲外またはブロックがあればカウント
                if (checkY < 0 || checkY >= arena.length || checkX < 0 || checkX >= arena[0].length || arena[checkY][checkX] !== 0) {
                    blockedCorners++;
                }
            }
            // 4つの角のうち3つ以上がブロックされていればT-Spinと判定
            // Mini T-Spin: 2つの前面ブロックと1つの背面ブロック
            // Full T-Spin: 3つのブロック
            // ここでは簡易的に3つ以上のブロックでT-Spinとする
            return blockedCorners >= 3;
        }


        function playerRotate(isRight = true) {
            const clonedMatrix = player.matrix.map(row => [...row]);
            const originalPos = { x: player.pos.x, y: player.pos.y };

            const rotated = rotate(player.matrix, isRight);
            player.matrix = rotated;

            // SRS (Super Rotation System) Wall Kick data
            // For T, J, L, S, Z pieces
            const JLSZT_kicks = [
                // 0 -> R / R -> 0 (from 0 to R/1, and R/1 back to 0)
                [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
                // R -> 2 / 2 -> R
                [[0,0], [1,0], [1,-1], [0,2], [1,2]],
                // 2 -> L / L -> 2
                [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
                // L -> 0 / 0 -> L
                [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]]
            ];

            // For I piece
            const I_kicks = [
                // 0 -> R / R -> 0
                [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
                // R -> 2 / 2 -> R
                [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
                // 2 -> L / L -> 2
                [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
                // L -> 0 / 0 -> L
                [[0,0], [1,0], [-2,0], [1,-2], [-2,1]]
            ];

            let kicks;
            if (player.type === 'I') {
                kicks = I_kicks;
            } else {
                kicks = JLSZT_kicks;
            }

            // Simplified: Current implementation doesn't track rotation state (0, R, 2, L).
            // For full SRS, you'd need to know the current state to pick the correct kick table.
            // For now, we'll use a single table for all rotations for simplicity.
            const currentKicks = kicks[0]; // This means kicks are always from 0 to R or R to 0 reference.

            let rotatedSuccessfully = false;
            for (let i = 0; i < currentKicks.length; i++) {
                const [offsetX, offsetY] = currentKicks[i];
                player.pos.x = originalPos.x + offsetX;
                player.pos.y = originalPos.y + offsetY;

                if (!collide(arena, player)) {
                    rotatedSuccessfully = true;
                    break;
                }
            }

            if (rotatedSuccessfully) {
                // 回転が成功したらT-Spin判定を行う
                player.isTSpin = checkTSpin(originalPos, player.pos, player.matrix);
            } else {
                // 回転できなかった場合は元の状態に戻す
                player.matrix = clonedMatrix;
                player.pos = originalPos;
                player.isTSpin = false; // T-Spin判定をリセット
            }
        }


        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                const linesClearedThisDrop = arenaSweep(); // 消去したライン数を取得
                calculateScore(linesClearedThisDrop); // スコア計算に渡す
                playerReset();
                canHold = true; // 接地したらホールドを再有効化
                player.isTSpin = false; // 次のミノのためにT-Spinフラグをリセット
                return true; // 接地したことを示す
            }
            return false; // 接地していないことを示す
        }

        let softDropInterval = null; // ソフトドロップ用のインターバルID
        function startSoftDrop() {
            if (!softDropInterval) { // すでにソフトドロップ中ではない場合のみ開始
                playerDrop(); // まず1マス落とす
                softDropInterval = setInterval(() => {
                    const landed = playerDrop();
                    if (landed) { // 接地したらソフトドロップを停止
                        stopSoftDrop();
                    }
                }, 50); // より速い間隔でドロップ
            }
        }

        function stopSoftDrop() {
            clearInterval(softDropInterval);
            softDropInterval = null;
        }

        function hardDrop() {
            while (!collide(arena, player)) {
                player.pos.y++;
            }
            player.pos.y--;
            merge(arena, player);
            const linesClearedThisDrop = arenaSweep(); // 消去したライン数を取得
            calculateScore(linesClearedThisDrop); // スコア計算に渡す
            playerReset();
            canHold = true;
            dropCounter = 0; // ハードドロップ後に自動落下カウンターをリセット
            player.isTSpin = false; // 次のミノのためにT-Spinフラグをリセット
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
                return false; // 移動できなかった
            }
            return true; // 移動できた
        }

        const pieceShapes = {
            'T': [[0,1,0],[1,1,1],[0,0,0]],
            'O': [[1,1],[1,1]],
            'L': [[0,0,1],[1,1,1],[0,0,0]],
            'J': [[1,0,0],[1,1,1],[0,0,0]],
            'S': [[0,1,1],[1,1,0],[0,0,0]],
            'Z': [[1,1,0],[0,1,1],[0,0,0]],
            'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]
        };

        function createPiece(type) {
            return pieceShapes[type].map(row => [...row]);
        }

        let nextPieceBag = [];
        function fillBag() {
            const types = 'TJLOSZI'.split('');
            for (let i = types.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [types[i], types[j]] = [types[j], types[i]];
            }
            nextPieceBag = types;
        }

        function getNextPieceType() {
            if (nextPieceBag.length === 0) {
                fillBag();
            }
            return nextPieceBag.shift();
        }

        function arenaSweep() {
            let rowCount = 0;
            const fullRows = [];
            for (let y = arena.length - 1; y >= 0; --y) {
                let isRowFull = true;
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        isRowFull = false;
                        break;
                    }
                }
                if (isRowFull) {
                    fullRows.push(y); // 消去する行のインデックスを記録
                }
            }

            // 記録した行を削除し、新しい空行を上部に追加
            fullRows.forEach(y => {
                arena.splice(y, 1);
                arena.unshift(new Array(arena[0].length).fill(0));
            });
            rowCount = fullRows.length;

            if (rowCount > 0) {
                combo++; // ラインを消したら連鎖数を増やす
            } else {
                combo = -1; // ラインを消せなかったら連鎖をリセット
            }

            return rowCount; // 消したライン数を返す
        }

        function calculateScore(lines) {
            let baseScore = 0;
            let comboBonus = 0;
            let tSpinBonus = 0;

            // T-Spinボーナス（回転時に判定されたT-Spinフラグを見る）
            if (player.isTSpin) {
                if (lines === 0) {
                    // T-Spin O (no line clear) - modern games often give points for this too
                    // For simplicity, we'll only give T-Spin points if lines are cleared.
                } else if (lines === 1) { // T-Spin Single or Mini
                    // A more precise T-spin mini check requires understanding the kick used
                    // For simplicity, let's say if 1 line is cleared, it's a T-Spin Single.
                    // To implement T-Spin Mini, you'd need to differentiate more precisely, e.g., by checking
                    // the specific corners that are filled.
                    tSpinBonus = 800; // T-Spin Single
                } else if (lines === 2) { // T-Spin Double
                    tSpinBonus = 1200;
                } else if (lines === 3) { // T-Spin Triple
                    tSpinBonus = 1600;
                }
            }
            player.isTSpin = false; // スコア計算後、T-Spinフラグをリセット

            // 基本スコア（T-Spinボーナスがない場合のみ加算）
            if (tSpinBonus === 0) { // T-Spinボーナスが付かない場合のみ
                if (lines === 1) baseScore = 100;
                else if (lines === 2) baseScore = 300;
                else if (lines === 3) baseScore = 500;
                else if (lines === 4) baseScore = 800; // Tetris
            }

            // 連鎖ボーナス
            if (combo > 0) {
                comboBonus = combo * 50; // 連鎖数に応じて加算
            }

            score += baseScore + comboBonus + tSpinBonus;
            scoreElem.textContent = `スコア: ${score}`;
        }


        function getGhostPosition(player) {
            if (!player.matrix) return player.pos; // ミノがない場合は現在の位置を返す（描画しない）

            const ghost = {
                pos: { x: player.pos.x, y: player.pos.y },
                matrix: player.matrix
            };
            let ghostY = player.pos.y;
            while (true) {
                ghost.pos.y = ghostY + 1;
                if (collide(arena, ghost)) {
                    ghost.pos.y = ghostY;
                    break;
                }
                ghostY++;
            }
            return ghost.pos;
        }

        function drawAll() {
            context.fillStyle = '#fff';
            context.fillRect(0, 0, canvas.width, canvas.height);

            arena.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = colors[value];
                        context.strokeStyle = colors['border'];
                        context.lineWidth = 0.03;
                        context.fillRect(x, y, 1, 1);
                        context.strokeRect(x, y, 1, 1);
                    }
                });
            });

            // プレイヤーのミノが存在する場合のみゴーストピースと現在のミノを描画
            if (player.matrix && player.type) {
                const ghostPos = getGhostPosition(player);
                drawMatrix(player.matrix, ghostPos, context, 'ghost', 0.4); // ゴーストピース描画
                drawMatrix(player.matrix, player.pos, context, player.type); // 現在のミノ描画
            }


            // NEXTピースの描画
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            for (let i = 0; i < nextPieces.length; i++) {
                const pieceType = nextPieces[i].type;
                const pieceMatrix = createPiece(pieceType);
                // NEXTピースの描画位置調整（中央寄せ）
                const xOffset = (4 - pieceMatrix[0].length) / 2; // 4マス幅の中央に
                const yOffset = i * 4 + (4 - pieceMatrix.length) / 2; // 各ピースが4マス分のスペースを持つように
                drawMatrix(pieceMatrix, {x: xOffset, y: yOffset}, nextCtx, pieceType);
            }

            // ホールドピースの描画
            holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (hold.matrix && hold.type) {
                // ホールドピースの描画位置調整（中央寄せ）
                const xOffset = (4 - hold.matrix[0].length) / 2;
                const yOffset = (4 - hold.matrix.length) / 2;
                drawMatrix(hold.matrix, {x: xOffset, y: yOffset}, holdCtx, hold.type);
            }
        }

        let nextPieces = [];

        function playerReset() {
            // 新しいミノを生成
            player.type = nextPieces[0].type;
            player.matrix = createPiece(player.type);

            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

            nextPieces.shift(); // 1つ目のNEXTピースを消費
            nextPieces.push({type: getNextPieceType()}); // 新しいNEXTピースを追加

            // 新しいミノが生成された後に衝突判定を行う
            if (collide(arena, player)) {
                // ゲームオーバー
                cancelAnimationFrame(animationFrameId); // ゲームループを停止
                arena.forEach(row => row.fill(0)); // 盤面をクリア

                // 描画エラーを防ぐため、player.matrixとplayer.typeをnullにする
                player.matrix = null;
                player.type = null;

                stopSoftDrop(); // ソフトドロップ停止
                showGameOverModal(score, linesCleared); // ゲームオーバーモーダル表示

                // ゲームオーバー時のスコアとライン数を保存
                currentScoreAtGameOver = score;
                currentLinesClearedAtGameOver = linesCleared;

                // スコア、ライン数、ホールド、連鎖カウンターをリセット
                score = 0;
                linesCleared = 0;
                combo = -1;
                scoreElem.textContent = `スコア: ${score}`;
                hold.matrix = null;
                hold.type = null;
                nextPieces = []; // NEXTピースもリセット
            }
        }

        function holdPiece() {
            if (!canHold) return;

            const currentPieceType = player.type;
            const currentPieceMatrix = player.matrix.map(row => [...row]);

            let pieceToPlaceType;
            let pieceToPlaceMatrix;

            if (!hold.matrix) { // ホールドに何も入っていない場合
                hold.type = currentPieceType;
                hold.matrix = currentPieceMatrix;

                playerReset(); // NEXTピースから新しいミノを出す
            } else { // ホールドにミノが入っている場合
                pieceToPlaceType = hold.type;
                pieceToPlaceMatrix = hold.matrix.map(row => [...row]);

                hold.type = currentPieceType;
                hold.matrix = currentPieceMatrix;

                player.type = pieceToPlaceType;
                player.matrix = pieceToPlaceMatrix;
                player.pos.y = 0;
                player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

                if (collide(arena, player)) {
                    // ホールドからの入れ替えで衝突する場合、元のミノに戻す
                    player.type = currentPieceType;
                    player.matrix = currentPieceMatrix;
                    player.pos.y = 0;
                    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

                    hold.type = pieceToPlaceType;
                    hold.matrix = pieceToPlaceMatrix;
                    return; // 処理を中断（ホールド失敗）
                }
            }
            canHold = false; // ホールド後の連続ホールドを防ぐ
            player.isTSpin = false; // ホールド後なのでT-Spinフラグをリセット
        }

        let dropCounter = 0;
        let dropInterval = 1000; // 自動落下速度 (1秒)
        let lastTime = 0;
        let canHold = true;
        let animationFrameId; // requestAnimationFrameのIDを保持

        const arena = createMatrix(12, 20);
        const player = { pos: {x: 0, y: 0}, matrix: null, type: null, isTSpin: false }; // isTSpinを追加
        const hold = { matrix: null, type: null };

        function initGame() {
            // ゲーム状態をリセット
            arena.forEach(row => row.fill(0));
            score = 0;
            linesCleared = 0;
            combo = -1; // 連鎖カウンターもリセット
            player.isTSpin = false; // T-Spinフラグをリセット

            scoreElem.textContent = `スコア: ${score}`;
            hold.matrix = null;
            hold.type = null;
            nextPieces = []; // NEXTピースもリセット
            fillBag(); // 最初のバッグを補充

            // 初期NEXTピースを3つ生成
            for(let i = 0; i < 3; i++) {
                nextPieces.push({type: getNextPieceType()});
            }

            // 最初のミノをセット
            player.type = nextPieces[0].type;
            player.matrix = createPiece(player.type);
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

            nextPieces.shift(); // 最初のNEXTピースを消費
            nextPieces.push({type: getNextPieceType()}); // 新しいNEXTピースを追加

            canHold = true;
            dropCounter = 0;
            lastTime = 0;

            // すべてのタイマーを停止
            stopSoftDrop();

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // 既存のアニメーションループを停止
            }
            animationFrameId = requestAnimationFrame(update); // 新しいアニメーションループを開始
        }

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            // ソフトドロップがアクティブでない場合のみ、自動落下を処理
            if (!softDropInterval) {
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    playerDrop();
                    dropCounter %= dropInterval; // 自動落下が起きたらカウンターをリセット
                }
            }

            drawAll();

            animationFrameId = requestAnimationFrame(update);
        }

        // --- ランキングモーダル関連 ---
        const rankingOverlay = document.getElementById('ranking-overlay');
        const rankingList = document.getElementById('ranking-list');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');

        const ITEMS_PER_PAGE = 10;
        let currentPage = 0;
        let allScores = [];

        function showRankingModal() {
            rankingOverlay.style.display = 'flex';
            fetchRankingData();
        }

        function hideRankingModal() {
            rankingOverlay.style.display = 'none';
        }

        function fetchRankingData() {
            db.collection("tetris-scores")
                .orderBy("score", "desc")
                .get()
                .then(snapshot => {
                    allScores = [];
                    snapshot.forEach(doc => {
                        allScores.push(doc.data());
                    });
                    currentPage = 0; // Always start from the first page
                    renderRankingPage();
                })
                .catch((error) => {
                    console.error("Error fetching ranking: ", error);
                    rankingList.innerHTML = "<p>ランキングの取得に失敗しました。</p>";
                    prevPageBtn.disabled = true;
                    nextPageBtn.disabled = true;
                });
        }

        function renderRankingPage() {
            rankingList.innerHTML = '';
            const startIndex = currentPage * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            const scoresToDisplay = allScores.slice(startIndex, endIndex);

            if (scoresToDisplay.length === 0 && currentPage > 0) {
                // If the current page is empty and not the first page, go back to the previous page
                currentPage--;
                renderRankingPage();
                return;
            }

            scoresToDisplay.forEach((d, index) => {
                const displayName = d.name.length > 10 ? d.name.substring(0, 10) + '...' : d.name; // Truncate name
                rankingList.innerHTML += `<li>${startIndex + index + 1}. ${displayName} - ${d.score}点 (${d.linesCleared}ライン)</li>`;
            });

            prevPageBtn.disabled = currentPage === 0;
            nextPageBtn.disabled = endIndex >= allScores.length;
        }

        prevPageBtn.addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                renderRankingPage();
            }
        });

        nextPageBtn.addEventListener('click', () => {
            if ((currentPage + 1) * ITEMS_PER_PAGE < allScores.length) {
                currentPage++;
                renderRankingPage();
            }
        });

        // --- ゲームオーバーモーダル関連 ---
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreDisplay = document.getElementById('final-score-display');
        const linesClearedDisplay = document.getElementById('lines-cleared-display');

        // ゲームオーバー時のスコアとライン数を一時的に保持する変数
        let currentScoreAtGameOver = 0;
        let currentLinesClearedAtGameOver = 0;

        function showGameOverModal(finalScore, finalLinesCleared) {
            currentScoreAtGameOver = finalScore; // スコアを一時的に保存
            currentLinesClearedAtGameOver = finalLinesCleared; // ライン数も一時的に保存

            finalScoreDisplay.textContent = `スコア: ${finalScore}`;
            linesClearedDisplay.textContent = `消したライン数: ${finalLinesCleared}`;
            gameOverOverlay.style.display = 'flex';
        }

        function hideGameOverModalAndShowMenu() {
            gameOverOverlay.style.display = 'none';
            showModeSelection(); // ゲームオーバー後、メインメニューに戻る
        }

        function registerRanking() {
            const name = prompt("ランキングに登録する名前を入力してください:");
            if (name) {
                db.collection("tetris-scores")
                    .add({
                        name,
                        score: currentScoreAtGameOver, // ゲームオーバー時のスコアを使用
                        linesCleared: currentLinesClearedAtGameOver, // ゲームオーバー時のライン数も保存
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    })
                    .then(() => {
                        console.log("Score saved successfully!");
                        alert("ランキングを登録しました！");
                        hideGameOverModal(); // 登録成功後、ゲームオーバーモーダルを閉じる
                        showRankingModal(); // 登録後、ランキングを表示
                    })
                    .catch((error) => {
                        console.error("Error saving score: ", error);
                        alert("ランキングの登録に失敗しました。");
                        hideGameOverModalAndShowMenu(); // 失敗したらゲームオーバーモーダルを閉じてメニューに戻る
                    });
            } else {
                hideGameOverModalAndShowMenu(); // 名前の入力がキャンセルされたらゲームオーバーモーダルを閉じてメニューに戻る
            }
        }

        function hideGameOverModal() {
            gameOverOverlay.style.display = 'none';
        }


        // --- 操作モード関連 ---
        let currentControlMode = 'button'; // 'button' or 'gesture'
        const uiButtons = document.getElementById('ui');
        const overlay = document.getElementById('overlay'); // This is now the main menu modal
        const tetrisCanvas = document.getElementById('tetris');
        const holdArea = document.getElementById('hold');


        function setControlMode(mode) {
            currentControlMode = mode;
            overlay.style.display = 'none'; // Main menu modal (overlay)を非表示にする

            // キーボードイベントリスナーは常に有効にしておく（PCユーザーのため）
            // 二重登録を防ぐために、一度削除してから追加
            document.removeEventListener('keydown', handleKeyboardInput);
            document.removeEventListener('keyup', handleKeyboardInputUp);
            document.addEventListener('keydown', handleKeyboardInput);
            document.addEventListener('keyup', handleKeyboardInputUp);

            // ジェスチャーモードでもボタンUIは常に表示するように変更
            uiButtons.style.display = 'grid'; // ボタンUIを常に表示

            if (mode === 'button') {
                // タッチジェスチャーのイベントリスナーを削除
                tetrisCanvas.removeEventListener('touchstart', handleTouchStart);
                tetrisCanvas.removeEventListener('touchmove', handleTouchMove);
                tetrisCanvas.removeEventListener('touchend', handleTouchEnd);
                holdArea.removeEventListener('touchstart', handleHoldTouch);

            } else if (mode === 'gesture') {
                // タッチジェスチャーのイベントリスナーを追加
                tetrisCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                tetrisCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                tetrisCanvas.addEventListener('touchend', handleTouchEnd);
                holdArea.addEventListener('touchstart', handleHoldTouch);

            }
            initGame(); // ゲーム開始
        }

        function showModeSelection() {
            // This function now effectively acts as "show main menu"
            overlay.style.display = 'flex'; // モーダルを表示
        }

        // モーダルボタンのイベントリスナー
        document.getElementById('btn-mode-button').addEventListener('click', () => setControlMode('button'));
        document.getElementById('btn-mode-gesture').addEventListener('click', () => setControlMode('gesture'));
        document.getElementById('btn-show-ranking').addEventListener('click', showRankingModal);


        // --- キーボード入力ハンドラー ---
        function handleKeyboardInput(event) {
            if (event.key === 'ArrowLeft') playerMove(-1); // 左右は1マス移動
            else if (event.key === 'ArrowRight') playerMove(1); // 左右は1マス移動
            else if (event.key === 'ArrowDown') startSoftDrop(); // 長押し有効
            else if (event.key === 'ArrowUp') hardDrop();
            else if (event.key === 'c' || event.key === 'C') holdPiece();
            else if (event.key === 'z' || event.key === 'Z') playerRotate(false); // 左回転
            else if (event.key === 'x' || event.key === 'X') playerRotate(true);  // 右回転
        }

        function handleKeyboardInputUp(event) {
            if (event.key === 'ArrowDown') {
                stopSoftDrop();
            }
            // 左右は長押ししないのでkeyupでの処理は不要
        }

        // --- タッチジェスチャー関連 ---
        let startX = 0;
        let startY = 0;
        let lastMoveTime = 0; // 最後に移動を処理した時刻
        const moveDebounceTime = 100; // 横移動のデバウンス時間 (ms)
        let lastProcessedTouchX = 0; // タッチムーブで最後に処理したX座標
        let lastProcessedTouchY = 0; // タッチムーブで最後に処理したY座標

        const lateralMoveThreshold = 30; // 横移動を開始するスワイプ距離 (px) - 厳しめに
        const hardDropSwipeThreshold = 50; // ハードドロップと認識する縦スワイプ距離 (px) - 厳しめに
        const softDropSwipeThreshold = 30; // ソフトドロップと認識する縦スワイプ距離 (px)
        const rotationTapThreshold = 10; // タップと認識する距離（回転用）


        function handleTouchStart(event) {
            if (currentControlMode !== 'gesture') return; // ジェスチャーモードでのみ処理

            event.preventDefault(); // スクロールを防ぐ
            startX = event.touches[0].clientX;
            startY = event.touches[0].clientY;
            lastProcessedTouchX = startX;
            lastProcessedTouchY = startY;

            stopSoftDrop(); // 新しいタッチでソフトドロップを停止
        }

        function handleTouchMove(event) {
            if (currentControlMode !== 'gesture') return; // ジェスチャーモードでのみ処理

            event.preventDefault(); // スクロールを防ぐ
            const currentTime = Date.now();
            const currentX = event.touches[0].clientX;
            const currentY = event.touches[0].clientY;

            const deltaXSinceStart = currentX - startX; // 開始位置からの総移動量
            const deltaYSinceStart = currentY - startY; // 開始位置からの総移動量

            // 横移動（連続処理）
            // 最後の処理位置からの差分で判定し、デバウンスを適用
            if (currentTime - lastMoveTime > moveDebounceTime) {
                const diffX = currentX - lastProcessedTouchX;
                if (Math.abs(diffX) > lateralMoveThreshold / 2) { // 閾値の半分で微調整
                    const dir = (diffX > 0) ? 1 : -1;
                    if (playerMove(dir)) {
                        lastProcessedTouchX = currentX;
                        lastMoveTime = currentTime;
                    }
                }
            }


            // 下スワイプ（ソフトドロップ継続）
            // 最初のタッチ位置からの総移動量で判定
            if (deltaYSinceStart > softDropSwipeThreshold && Math.abs(deltaYSinceStart) > Math.abs(deltaXSinceStart)) {
                startSoftDrop(); // ソフトドロップ開始
            } else if (deltaYSinceStart <= 0 && softDropInterval) { // 上方向に戻ったり、閾値未満になったらソフトドロップを停止
                stopSoftDrop();
            }
        }

        function handleTouchEnd(event) {
            if (currentControlMode !== 'gesture') return; // ジェスチャーモードでのみ処理

            stopSoftDrop(); // 指を離したらソフトドロップを停止

            const endX = event.changedTouches[0].clientX;
            const endY = event.changedTouches[0].clientY;

            const deltaX = endX - startX; // タッチ開始位置からの総移動量
            const deltaY = endY - startY; // タッチ開始位置からの総移動量

            // ハードドロップ（上スワイプ）
            // 上方向への移動量がハードドロップの閾値を超え、かつ縦移動が横移動より優勢の場合
            if (deltaY < -hardDropSwipeThreshold && Math.abs(deltaY) > Math.abs(deltaX)) {
                hardDrop();
            }
            // 回転（タップ）
            // いずれのスワイプ操作も認識されず、かつ移動量がタップの閾値内の場合
            else if (Math.abs(deltaX) < rotationTapThreshold && Math.abs(deltaY) < rotationTapThreshold) {
                const rect = tetrisCanvas.getBoundingClientRect();
                const touchX = endX - rect.left;

                if (touchX < rect.width / 2) {
                    playerRotate(false); // 左半分タップで左回転
                } else {
                    playerRotate(true); // 右半分タップで右回転
                }
            }
        }

        function handleHoldTouch(event) {
            if (currentControlMode !== 'gesture') return; // ジェスチャーモードでのみ処理
            event.preventDefault();
            holdPiece();
        }

        // ゲーム開始時にモード選択を表示
        showModeSelection();
    </script>
</body>
</html>
