<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect Four AIæœ€é©è§£ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        ul {
            list-style: disc;
            margin-left: 20px;
            margin-bottom: 20px;
        }
        ol {
            list-style: decimal;
            margin-left: 20px;
            margin-bottom: 20px;
        }
        .advice-section {
            background-color: #e9f7ff;
            border-left: 5px solid #007bff;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 4px;
        }
        .advice-section strong {
            color: #0056b3;
        }
        .game-area {
            text-align: center;
            margin-top: 30px;
        }
        .board-container {
            display: inline-block;
            background-color: #007bff; /* ã‚³ãƒã‚¯ãƒˆãƒ•ã‚©ãƒ¼ã®ãƒœãƒ¼ãƒ‰ã®è‰² */
            padding: 5px;
            border-radius: 50px; /* è§’ã‚’ä¸¸ãã™ã‚‹ */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .board {
            display: grid;
            grid-template-columns: repeat(7, 60px); /* ç¸¦ã®ã‚µã‚¤ã‚ºã‚’å°‘ã—å¤§ãã */
            grid-template-rows: repeat(6, 60px);
            border: 1px solid #ccc;
            width: fit-content;
            margin: 0 auto;
            border-radius: 45px; /* ãƒœãƒ¼ãƒ‰è‡ªä½“ã®è§’ã‚‚ä¸¸ã */
            overflow: hidden; /* å­è¦ç´ ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã« */
        }
        .cell {
            width: 50px; /* éš™é–“ã‚’è€ƒæ…®ã—ã¦å°ã•ã */
            height: 50px;
            background-color: #fff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #555;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            margin: 5px; /* ã‚»ãƒ«é–“ã®éš™é–“ã‚’åºƒã’ã‚‹ */
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .cell.empty:hover {
            background-color: #e0e0e0;
        }
        .cell.player1 {
            background-color: #ff4500; /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®è‰² (èµ¤) */
        }
        .cell.player2 {
            background-color: #ffd700; /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®è‰² (é»„) */
        }
        .player-turn {
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
            color: #0056b3;
        }
        .button-group button {
            margin: 10px 5px;
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #findOptimalMoveButton {
            background-color: #28a745;
            color: white;
        }
        #findOptimalMoveButton:hover {
            background-color: #218838;
        }
        #resetBoardButton {
            background-color: #dc3545;
            color: white;
        }
        #resetBoardButton:hover {
            background-color: #c82333;
        }
        #optimalMoveOutput {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #cce5ff;
            border-radius: 5px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #0056b3;
            flex-wrap: wrap; /* å†…å®¹ãŒã¯ã¿å‡ºã‚‹å ´åˆã®ãŸã‚ã«è¿½åŠ  */
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Connect Four AIæœ€é©è§£ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        <p>ã“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã¯ã€<a href="https://kenrick95.github.io/c4/" target="_blank">kenrick95.github.io/c4/</a> ã®Connect Four AIã«å‹ã¤ãŸã‚ã®ã€Œæ¬¡ã®ä¸€æ‰‹ã€ã®æœ€é©è§£ã‚’æ¢ã™ãŠæ‰‹ä¼ã„ã‚’ã—ã¾ã™ã€‚</p>
        <p>ç¾åœ¨ã®ç›¤é¢ã‚’å…¥åŠ›ã—ã€ã€Œæœ€é©è§£ã‚’æ¢ã™ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚AIãŒæ¬¡ã®æœ€é©ãªæ‰‹ã‚’è¨ˆç®—ã—ã¦æç¤ºã—ã¾ã™ã€‚</p>

        <div class="advice-section">
            <h2>AIæ”»ç•¥ã®åŸºæœ¬æˆ¦ç•¥</h2>
            <ul>
                <li><strong>å…ˆæ‰‹ã‚’æœ‰åˆ©ã«é€²ã‚ã‚‹:</strong> Connect Fourã§ã¯ã€ä¸­å¤®ã‚’æœ€åˆã«å–ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæœ‰åˆ©ã«ãªã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚</li>
                <li><strong>ãƒ•ã‚©ãƒ¼ã‚¹ãƒ ãƒ¼ãƒ– (å¼·åˆ¶æ‰‹) ã‚’è¦‹ã¤ã‘ã‚‹:</strong> ç›¸æ‰‹ã«ç‰¹å®šã®åˆ—ã«ç½®ã‹ã–ã‚‹ã‚’å¾—ãªã„çŠ¶æ³ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã§ã€å‹åˆ©ã«è¿‘ã¥ã‘ã¾ã™ã€‚</li>
                <li><strong>äºŒé‡è„…å¨ (Two-way threat) ã®ä½œæˆ:</strong> 2ãƒ¶æ‰€ã§åŒæ™‚ã«å‹åˆ©ã®å½¢ã‚’ä½œã‚‹ã“ã¨ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚AIã¯ç‰‡æ–¹ã®è„…å¨ã—ã‹é˜²ã’ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</li>
                <li><strong>å¥‡æ•°ãƒ»å¶æ•°åˆ—ã®åˆ©ç”¨:</strong> åˆ—ã®é«˜ã•ï¼ˆé§’ã®æ•°ï¼‰ãŒå¥‡æ•°ã‹å¶æ•°ã‹ã«ã‚ˆã£ã¦ã€æ¬¡ã®æ‰‹ç•ªã®å„ªä½æ€§ãŒå¤‰ã‚ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç‰¹ã«çµ‚ç›¤ã§é‡è¦ã«ãªã‚Šã¾ã™ã€‚</li>
                <li><strong>AIã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ã¶:</strong> ä½•åº¦ã‹ãƒ—ãƒ¬ã‚¤ã—ã¦ã¿ã¦ã€AIãŒã©ã®ã‚ˆã†ãªçŠ¶æ³ã§ã©ã®ã‚ˆã†ã«åå¿œã™ã‚‹ã‹ã‚’è¦³å¯Ÿã—ã¾ã—ã‚‡ã†ã€‚AIã¯ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¼·ãã€åˆ¥ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¼±ã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            </ul>
        </div>

        <div class="game-area">
            <div class="player-turn" id="playerTurn">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1 (èµ¤)</div>
            <div class="board-container">
                <div class="board" id="gameBoard">
                    </div>
            </div>
            <div class="button-group">
                <button id="findOptimalMoveButton">æœ€é©è§£ã‚’æ¢ã™</button>
                <button id="resetBoardButton">ç›¤é¢ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <div id="optimalMoveOutput">ã“ã“ã«AIã®æœ€é©è§£ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        </div>

        <p>ã‚ˆã‚Šæ·±ãå­¦ã³ãŸã„å ´åˆã¯ã€Connect Fourã®ã€ŒåŠ›æˆ¦å®šçŸ³ã€ã‚„ã€Œã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°ç†è«–ã€ã«ã¤ã„ã¦èª¿ã¹ã¦ã¿ã¦ãã ã•ã„ã€‚</p>
    </div>

    <script>
        const rows = 6;
        const cols = 7;
        const boardElement = document.getElementById('gameBoard');
        const playerTurnElement = document.getElementById('playerTurn');
        const findOptimalMoveButton = document.getElementById('findOptimalMoveButton');
        const resetBoardButton = document.getElementById('resetBoardButton');
        const optimalMoveOutput = document.getElementById('optimalMoveOutput');

        let board = Array(rows).fill(0).map(() => Array(cols).fill(0)); // 0:ç©º, 1:ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1(èµ¤), 2:ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2(é»„)
        let currentPlayer = 1; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ãŒå…ˆè¡Œ

        // ç›¤é¢ã‚’åˆæœŸåŒ–ãƒ»æç”»ã™ã‚‹é–¢æ•°
        function createBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    updateCell(cell, board[r][c]);
                    cell.addEventListener('click', () => handleCellClick(c));
                    boardElement.appendChild(cell);
                }
            }
            updatePlayerTurnDisplay();
        }

        // ã‚»ãƒ«ã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateCell(cellElement, player) {
            cellElement.classList.remove('player1', 'player2', 'empty');
            if (player === 1) {
                cellElement.classList.add('player1');
            } else if (player === 2) {
                cellElement.classList.add('player2');
            } else {
                cellElement.classList.add('empty');
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updatePlayerTurnDisplay() {
            playerTurnElement.textContent = `ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${currentPlayer} (${currentPlayer === 1 ? 'èµ¤' : 'é»„'})`;
        }

        // ã‚»ãƒ«ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç† (é§’ã‚’è½ã¨ã™)
        function handleCellClick(col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    board[r][col] = currentPlayer;
                    const cellElement = boardElement.querySelector(`[data-row="${r}"][data-col="${col}"]`);
                    updateCell(cellElement, currentPlayer);
                    
                    // å‹åˆ©åˆ¤å®š
                    if (checkWin(board, currentPlayer)) {
                        optimalMoveOutput.textContent = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${currentPlayer}ã®å‹åˆ©ã§ã™ï¼`;
                        disableBoardClicks();
                        return;
                    }
                    
                    // å¼•ãåˆ†ã‘åˆ¤å®š
                    if (getAvailableMoves(board).length === 0 && !checkWin(board, 1) && !checkWin(board, 2)) {
                        optimalMoveOutput.textContent = `å¼•ãåˆ†ã‘ã§ã™ï¼`;
                        disableBoardClicks();
                        return;
                    }

                    currentPlayer = (currentPlayer === 1) ? 2 : 1;
                    updatePlayerTurnDisplay();
                    optimalMoveOutput.textContent = 'ã“ã“ã«AIã®æœ€é©è§£ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚'; // ç›¤é¢å¤‰æ›´ã§ãƒªã‚»ãƒƒãƒˆ
                    return;
                }
            }
            optimalMoveOutput.textContent = `åˆ— ${col + 1} ã¯æº€æ¯ã§ã™ã€‚`;
        }

        // ãƒœãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯ã‚’ç„¡åŠ¹ã«ã™ã‚‹
        function disableBoardClicks() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.pointerEvents = 'none';
            });
        }

        // ãƒœãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯ã‚’æœ‰åŠ¹ã«ã™ã‚‹
        function enableBoardClicks() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.pointerEvents = 'auto';
            });
        }

        // ç›¤é¢ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        resetBoardButton.addEventListener('click', () => {
            board = Array(rows).fill(0).map(() => Array(cols).fill(0));
            currentPlayer = 1;
            createBoard();
            optimalMoveOutput.textContent = 'ã“ã“ã«AIã®æœ€é©è§£ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚';
            enableBoardClicks();
        });

        // =========================================================================
        // AI (Minimax with Alpha-Beta Pruning) ãƒ­ã‚¸ãƒƒã‚¯
        // =========================================================================

        const WIN_SCORE = 10000000; // å‹åˆ©ã®è©•ä¾¡ç‚¹ (ã•ã‚‰ã«å¤§ãã)
        const LOSE_SCORE = -WIN_SCORE; // æ•—åŒ—ã®è©•ä¾¡ç‚¹

        // ãƒœãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function copyBoard(board) {
            return board.map(row => [...row]);
        }

        // é§’ã‚’è½ã¨ã›ã‚‹è¡Œã‚’è¦‹ã¤ã‘ã‚‹
        function getNextEmptyRow(board, col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    return r;
                }
            }
            return -1; // åˆ—ãŒæº€æ¯
        }

        // åˆ©ç”¨å¯èƒ½ãªæ‰‹ï¼ˆé§’ã‚’ç½®ã‘ã‚‹åˆ—ï¼‰ã‚’å–å¾—ã™ã‚‹
        function getAvailableMoves(board) {
            const moves = [];
            for (let c = 0; c < cols; c++) {
                if (board[0][c] === 0) { // æœ€ä¸Šæ®µãŒç©ºãªã‚‰ãã®åˆ—ã¯ã¾ã ç½®ã‘ã‚‹
                    moves.push(c);
                }
            }
            return moves;
        }

        // å‹åˆ©åˆ¤å®š (ä¿®æ­£ç‰ˆ)
        function checkWin(boardState, player) {
            // æ°´å¹³æ–¹å‘
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (boardState[r][c] === player &&
                        boardState[r][c+1] === player &&
                        boardState[r][c+2] === player &&
                        boardState[r][c+3] === player) {
                        return true;
                    }
                }
            }

            // å‚ç›´æ–¹å‘
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c < cols; c++) {
                    if (boardState[r][c] === player &&
                        boardState[r+1][c] === player &&
                        boardState[r+2][c] === player &&
                        boardState[r+3][c] === player) {
                        return true;
                    }
                }
            }

            // å³ä¸ŠãŒã‚Šæ–œã‚ (\)
            // r ã¯3ä»¥ä¸Š (ä¸‹ã‹ã‚‰ä¸Šã«3ãƒã‚¹é€²ã‚€å¿…è¦ãŒã‚ã‚‹)
            // c ã¯0ã‹ã‚‰cols-4ã¾ã§
            for (let r = 3; r < rows; r++) { // rã¯3ã‹ã‚‰5ã¾ã§ (0-indexed)
                for (let c = 0; c <= cols - 4; c++) { // cã¯0ã‹ã‚‰3ã¾ã§
                    if (boardState[r][c] === player &&
                        boardState[r-1][c+1] === player &&
                        boardState[r-2][c+2] === player &&
                        boardState[r-3][c+3] === player) {
                        return true;
                    }
                }
            }

            // å³ä¸‹ãŒã‚Šæ–œã‚ (/)
            // r ã¯0ã‹ã‚‰rows-4ã¾ã§
            // c ã¯0ã‹ã‚‰cols-4ã¾ã§
            for (let r = 0; r <= rows - 4; r++) { // rã¯0ã‹ã‚‰2ã¾ã§
                for (let c = 0; c <= cols - 4; c++) { // cã¯0ã‹ã‚‰3ã¾ã§
                    if (boardState[r][c] === player &&
                        boardState[r+1][c+1] === player &&
                        boardState[r+2][c+2] === player &&
                        boardState[r+3][c+3] === player) {
                        return true;
                    }
                }
            }
            return false;
        }

        // ç›¤é¢è©•ä¾¡é–¢æ•°
        function evaluateBoard(boardState, player) {
            let score = 0;
            const opponent = (player === 1) ? 2 : 1;

            // å„æ–¹å‘ã«4ã¤ã®é€£ç¶šã™ã‚‹é§’ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©•ä¾¡
            function scoreWindow(window) {
                let pCount = 0;
                let oppCount = 0;
                let emptyCount = 0;

                for (let piece of window) {
                    if (piece === player) {
                        pCount++;
                    } else if (piece === opponent) {
                        oppCount++;
                    } else {
                        emptyCount++;
                    }
                }

                // å‹åˆ©ãƒ»æ•—åŒ—ã®å³æ™‚åˆ¤å®šï¼ˆMinimaxã®çµ‚äº†æ¡ä»¶ã¨é‡è¤‡ã™ã‚‹ãŒã€è©•ä¾¡é–¢æ•°å†…ã§ã‚‚è€ƒæ…®ã™ã‚‹ã“ã¨ã§æ¢ç´¢ã®åŠ¹ç‡ã¨ç²¾åº¦ã‚’ä¸Šã’ã‚‹ï¼‰
                if (pCount === 4) return WIN_SCORE;
                if (oppCount === 4) return LOSE_SCORE;

                // ã‚ªãƒ¼ãƒ—ãƒ³ãª3ã¤ä¸¦ã³ã®è©•ä¾¡ (éå¸¸ã«é‡è¦)
                if (pCount === 3 && emptyCount === 1) return 10000; // è‡ªåˆ†ã®ã‚ªãƒ¼ãƒ—ãƒ³3 (æ¬¡ã®æ‰‹ã§å‹ã¡)
                if (oppCount === 3 && emptyCount === 1) return -9000; // ç›¸æ‰‹ã®ã‚ªãƒ¼ãƒ—ãƒ³3 (æ¬¡ã®æ‰‹ã§è² ã‘ã‚‹)

                // ã‚ªãƒ¼ãƒ—ãƒ³ãª2ã¤ä¸¦ã³ã®è©•ä¾¡
                if (pCount === 2 && emptyCount === 2) return 1000;
                if (oppCount === 2 && emptyCount === 2) return -900;
                
                return 0;
            }

            // ä¸­å¤®ã®åˆ—ã‚’å„ªå…ˆã™ã‚‹ (æˆ¦ç•¥çš„ä¾¡å€¤ãŒé«˜ã„)
            for (let r = 0; r < rows; r++) {
                if (boardState[r][3] === player) score += 5; 
                else if (boardState[r][3] === opponent) score -= 5;
            }

            // å…¨ã¦ã®æ–¹å‘ã®4ãƒã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è©•ä¾¡
            // æ°´å¹³æ–¹å‘
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    const window = [boardState[r][c], boardState[r][c+1], boardState[r][c+2], boardState[r][c+3]];
                    score += scoreWindow(window);
                }
            }

            // å‚ç›´æ–¹å‘
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    const window = [boardState[r][c], boardState[r+1][c], boardState[r+2][c], boardState[r+3][c]];
                    score += scoreWindow(window);
                }
            }

            // å³ä¸ŠãŒã‚Šæ–œã‚
            for (let r = 3; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    const window = [boardState[r][c], boardState[r-1][c+1], boardState[r-2][c+2], boardState[r-3][c+3]];
                    score += scoreWindow(window);
                }
            }

            // å³ä¸‹ãŒã‚Šæ–œã‚
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    const window = [boardState[r][c], boardState[r+1][c+1], boardState[r+2][c+2], boardState[r+3][c+3]];
                    score += scoreWindow(window);
                }
            }

            return score;
        }

        // Minimaxã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  (å†å¸°é–¢æ•°)
        function minimax(boardState, depth, alpha, beta, maximizingPlayer, aiPlayer, humanPlayer) {
            // çµ‚äº†æ¡ä»¶:
            // 1. å‹åˆ©ãƒ»æ•—åŒ—ã®ãƒã‚§ãƒƒã‚¯
            // 2. å¼•ãåˆ†ã‘ã®ãƒã‚§ãƒƒã‚¯
            // 3. æ·±ã•åˆ¶é™ã«é”ã—ãŸ

            // ã¾ãšå‹åˆ©åˆ¤å®š
            if (checkWin(boardState, aiPlayer)) { // AIãŒå‹åˆ©
                return WIN_SCORE + depth; // å‹åˆ©ã‚¹ã‚³ã‚¢ã«æ·±ã•ã‚’åŠ ç®—ã—ã€ã‚ˆã‚Šæ—©ãå‹ã¦ã‚‹æ‰‹ã‚’å„ªå…ˆ
            }
            if (checkWin(boardState, humanPlayer)) { // ç›¸æ‰‹ãŒå‹åˆ©
                return LOSE_SCORE - depth; // æ•—åŒ—ã‚¹ã‚³ã‚¢ã‹ã‚‰æ·±ã•ã‚’æ¸›ç®—ã—ã€ã‚ˆã‚Šé…ãè² ã‘ã‚‹æ‰‹ã‚’å„ªå…ˆï¼ˆè² ã‘ç¢ºå®šãªã‚‰ï¼‰
            }
            
            // å¼•ãåˆ†ã‘åˆ¤å®š
            if (getAvailableMoves(boardState).length === 0) {
                return 0; // å¼•ãåˆ†ã‘
            }

            // æ·±ã•åˆ¶é™
            if (depth === 0) {
                return evaluateBoard(boardState, aiPlayer); // AIãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¦–ç‚¹ã§ã®è©•ä¾¡
            }

            const availableMoves = getAvailableMoves(boardState);
            // ä¸­å¤®ã«è¿‘ã„åˆ—ã‹ã‚‰æ¢ç´¢ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ã«è‰¯ã„æ‰‹ã‚’è¦‹ã¤ã‘ã‚„ã™ãã™ã‚‹
            availableMoves.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));

            if (maximizingPlayer) { // AI (aiPlayer) ã®ç•ª: è©•ä¾¡ã‚’æœ€å¤§åŒ–
                let maxEval = -Infinity;
                for (let col of availableMoves) {
                    const row = getNextEmptyRow(boardState, col);
                    if (row !== -1) {
                        const newBoard = copyBoard(boardState);
                        newBoard[row][col] = aiPlayer;
                        // æ¬¡ã®å‘¼ã³å‡ºã—ã¯ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (humanPlayer) ã®ç•ªãªã®ã§ minimizingPlayer = false, currentPlayerValue = humanPlayer
                        const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, aiPlayer, humanPlayer); 
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        if (beta <= alpha) break; // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Š
                    }
                }
                return maxEval;
            } else { // ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (humanPlayer) ã®ç•ª: è©•ä¾¡ã‚’æœ€å°åŒ–
                let minEval = Infinity;
                for (let col of availableMoves) {
                    const row = getNextEmptyRow(boardState, col);
                    if (row !== -1) {
                        const newBoard = copyBoard(boardState);
                        newBoard[row][col] = humanPlayer;
                        // æ¬¡ã®å‘¼ã³å‡ºã—ã¯AIãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (aiPlayer) ã®ç•ªãªã®ã§ maximizingPlayer = true, currentPlayerValue = aiPlayer
                        const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, aiPlayer, humanPlayer); 
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        if (beta <= alpha) break; // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Š
                    }
                }
                return minEval;
            }
        }

        // æœ€é©ãªæ‰‹ã‚’è¦‹ã¤ã‘ã‚‹é–¢æ•°
        findOptimalMoveButton.addEventListener('click', () => {
            optimalMoveOutput.innerHTML = 'è¨ˆç®—ä¸­... <span class="loading-spinner"></span>';
            disableBoardClicks(); // è¨ˆç®—ä¸­ã¯ç›¤é¢æ“ä½œã‚’ç„¡åŠ¹åŒ–

            // éåŒæœŸã§è¨ˆç®—ã‚’å®Ÿè¡Œã—ã€UIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„
            setTimeout(() => {
                const availableMoves = getAvailableMoves(board);
                if (availableMoves.length === 0) {
                    optimalMoveOutput.textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†ã§ã™ã€‚';
                    enableBoardClicks();
                    return;
                }

                let bestMove = -1;
                let bestScore = -Infinity; 
                const depth = 6; // æ¢ç´¢æ·±ã•ã‚’å°‘ã—æ·±ãè¨­å®š (èª¿æ•´å¯èƒ½ã€æ·±ã™ãã‚‹ã¨é…ããªã‚‹)
                // ã“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯å¸¸ã« currentPlayer ã®æ‰‹ç•ªã§ã®æœ€é©è§£ã‚’æ¢ã™
                const aiPlayer = currentPlayer;
                const humanPlayer = (currentPlayer === 1) ? 2 : 1;

                // å¯èƒ½ãªæ‰‹ã‚’è©•ä¾¡
                const sortedMoves = [...availableMoves].sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));

                for (let col of sortedMoves) {
                    const newBoard = copyBoard(board);
                    const row = getNextEmptyRow(newBoard, col);
                    if (row !== -1) {
                        newBoard[row][col] = aiPlayer; // ä»®ã«AI (currentPlayer) ã®é§’ã‚’ç½®ã
                        
                        // ã“ã®ä¸€æ‰‹ã§AI (currentPlayer) ãŒå‹åˆ©ã™ã‚‹å ´åˆã€ãã‚ŒãŒæœ€å„ªå…ˆã®æœ€é©è§£
                        if (checkWin(newBoard, aiPlayer)) {
                            bestMove = col;
                            bestScore = WIN_SCORE;
                            break; 
                        }

                        // Minimaxã§ç›¸æ‰‹ã®æœ€å–„æ‰‹ã‚’è€ƒæ…®ã—ãŸä¸Šã§ã®è©•ä¾¡
                        // minimaxã®æœ€åˆã®å‘¼ã³å‡ºã—ã¯ã€ä»®ã«é§’ã‚’ç½®ã„ãŸå¾Œã®ç›¤é¢ãªã®ã§ã€
                        // ç›¸æ‰‹ (humanPlayer) ã®ç•ªã¨ã—ã¦ `maximizingPlayer = false` ã§å‘¼ã³å‡ºã™
                        // ãŸã ã—ã€ã‚¹ã‚³ã‚¢ã®è©•ä¾¡ã¯ã‚ãã¾ã§ `aiPlayer` è¦–ç‚¹ã§è¡Œã‚ã‚Œã‚‹
                        const score = minimax(newBoard, depth - 1, -Infinity, Infinity, false, aiPlayer, humanPlayer); 
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = col;
                        }
                    }
                }

                if (bestMove !== -1) {
                    let message = `æœ€é©è§£ã¯ **åˆ— ${bestMove + 1}** ã§ã™ã€‚`;
                    if (bestScore >= WIN_SCORE - depth) { // å‹åˆ©ã‚¹ã‚³ã‚¢ã«è¿‘ã„ï¼ˆæ·±ã•åˆ†èª¿æ•´ï¼‰
                        message += ` (ã“ã®ä¸€æ‰‹ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${aiPlayer} (${aiPlayer === 1 ? 'èµ¤' : 'é»„'}) ãŒå‹åˆ©ã—ã¾ã™ï¼ ğŸ‰)`;
                    } else if (bestScore <= LOSE_SCORE + depth) { // æ•—åŒ—ã‚¹ã‚³ã‚¢ã«è¿‘ã„
                        message += ` (ã“ã®ä¸€æ‰‹ã§ã‚‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${aiPlayer} (${aiPlayer === 1 ? 'èµ¤' : 'é»„'}) ã®æ•—åŒ—ã¯é¿ã‘ã‚‰ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“... ğŸ˜¥)`;
                    } else if (bestScore >= 9000) { // ã‹ãªã‚Šé«˜ã„è©•ä¾¡
                        message += ` (ã“ã®æ‰‹ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${aiPlayer} (${aiPlayer === 1 ? 'èµ¤' : 'é»„'}) ãŒéå¸¸ã«æœ‰åˆ©ãªå±€é¢ã«ãªã‚Šã¾ã™ï¼)`
                    } else if (bestScore <= -8000) { // ã‹ãªã‚Šä½ã„è©•ä¾¡
                        message += ` (ã“ã®æ‰‹ã§ã‚‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${aiPlayer} (${aiPlayer === 1 ? 'èµ¤' : 'é»„'}) ã¯ä¸åˆ©ãªçŠ¶æ³ã«é™¥ã‚Šã¾ã™ã€‚)`
                    }
                    optimalMoveOutput.innerHTML = message;
                } else {
                    optimalMoveOutput.textContent = 'æœ€é©ãªæ‰‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚'; 
                }
                enableBoardClicks(); // è¨ˆç®—çµ‚äº†å¾Œã€ç›¤é¢æ“ä½œã‚’æœ‰åŠ¹åŒ–
            }, 10); // çŸ­ã„é…å»¶ã‚’å…¥ã‚Œã¦UIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
        });

        // åˆæœŸè¡¨ç¤º
        createBoard();
    </script>
</body>
</html>
