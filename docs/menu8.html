<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect Four AIæœ€é©è§£ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            margin-bottom: 40px;
        }
        ul {
            list-style: disc;
            margin-left: 20px;
            margin-bottom: 20px;
        }
        ol {
            list-style: decimal;
            margin-left: 20px;
            margin-bottom: 20px;
        }
        .advice-section {
            background-color: #e9f7ff;
            border-left: 5px solid #007bff;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 4px;
        }
        .advice-section strong {
            color: #0056b3;
        }
        .game-area {
            text-align: center;
            margin-top: 30px;
        }
        .board-container {
            display: inline-block;
            background-color: #007bff; /* ã‚³ãƒã‚¯ãƒˆãƒ•ã‚©ãƒ¼ã®ãƒœãƒ¼ãƒ‰ã®è‰² */
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .board {
            display: grid;
            grid-template-columns: repeat(7, 60px); /* ç¸¦ã®ã‚µã‚¤ã‚ºã‚’å°‘ã—å¤§ãã */
            grid-template-rows: repeat(6, 60px);
            border: 1px solid #ccc;
            width: fit-content;
            margin: 0 auto;
        }
        .cell {
            width: 58px; /* éš™é–“ã‚’è€ƒæ…®ã—ã¦å°ã•ã */
            height: 58px;
            background-color: #fff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #555;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            margin: 1px; /* ã‚»ãƒ«é–“ã®éš™é–“ */
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .cell.empty:hover {
            background-color: #e0e0e0;
        }
        .cell.player1 {
            background-color: #ff4500; /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®è‰² (èµ¤) */
        }
        .cell.player2 {
            background-color: #ffd700; /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®è‰² (é»„) */
        }
        .player-turn {
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
            color: #0056b3;
        }
        .button-group button {
            margin: 10px 5px;
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #findOptimalMoveButton {
            background-color: #28a745;
            color: white;
        }
        #findOptimalMoveButton:hover {
            background-color: #218838;
        }
        #resetBoardButton {
            background-color: #dc3545;
            color: white;
        }
        #resetBoardButton:hover {
            background-color: #c82333;
        }
        #optimalMoveOutput {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #cce5ff;
            border-radius: 5px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #0056b3;
            flex-wrap: wrap; /* å†…å®¹ãŒã¯ã¿å‡ºã‚‹å ´åˆã®ãŸã‚ã«è¿½åŠ  */
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Connect Four AIæœ€é©è§£ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        <p>ã“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã¯ã€<a href="https://kenrick95.github.io/c4/" target="_blank">kenrick95.github.io/c4/</a> ã®Connect Four AIã«å‹ã¤ãŸã‚ã®ã€Œæ¬¡ã®ä¸€æ‰‹ã€ã®æœ€é©è§£ã‚’æ¢ã™ãŠæ‰‹ä¼ã„ã‚’ã—ã¾ã™ã€‚</p>
        <p>ç¾åœ¨ã®ç›¤é¢ã‚’å…¥åŠ›ã—ã€ã€Œæœ€é©è§£ã‚’æ¢ã™ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚AIãŒæ¬¡ã®æœ€é©ãªæ‰‹ã‚’è¨ˆç®—ã—ã¦æç¤ºã—ã¾ã™ã€‚</p>

        <div class="advice-section">
            <h2>AIæ”»ç•¥ã®åŸºæœ¬æˆ¦ç•¥</h2>
            <ul>
                <li><strong>å…ˆæ‰‹ã‚’æœ‰åˆ©ã«é€²ã‚ã‚‹:</strong> Connect Fourã§ã¯ã€ä¸­å¤®ã‚’æœ€åˆã«å–ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæœ‰åˆ©ã«ãªã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚</li>
                <li><strong>ãƒ•ã‚©ãƒ¼ã‚¹ãƒ ãƒ¼ãƒ– (å¼·åˆ¶æ‰‹) ã‚’è¦‹ã¤ã‘ã‚‹:</strong> ç›¸æ‰‹ã«ç‰¹å®šã®åˆ—ã«ç½®ã‹ã–ã‚‹ã‚’å¾—ãªã„çŠ¶æ³ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã§ã€å‹åˆ©ã«è¿‘ã¥ã‘ã¾ã™ã€‚</li>
                <li><strong>äºŒé‡è„…å¨ (Two-way threat) ã®ä½œæˆ:</strong> 2ãƒ¶æ‰€ã§åŒæ™‚ã«å‹åˆ©ã®å½¢ã‚’ä½œã‚‹ã“ã¨ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚AIã¯ç‰‡æ–¹ã®è„…å¨ã—ã‹é˜²ã’ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</li>
                <li><strong>å¥‡æ•°ãƒ»å¶æ•°åˆ—ã®åˆ©ç”¨:</strong> åˆ—ã®é«˜ã•ï¼ˆé§’ã®æ•°ï¼‰ãŒå¥‡æ•°ã‹å¶æ•°ã‹ã«ã‚ˆã£ã¦ã€æ¬¡ã®æ‰‹ç•ªã®å„ªä½æ€§ãŒå¤‰ã‚ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ç‰¹ã«çµ‚ç›¤ã§é‡è¦ã«ãªã‚Šã¾ã™ã€‚</li>
                <li><strong>AIã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ã¶:</strong> ä½•åº¦ã‹ãƒ—ãƒ¬ã‚¤ã—ã¦ã¿ã¦ã€AIãŒã©ã®ã‚ˆã†ãªçŠ¶æ³ã§ã©ã®ã‚ˆã†ã«åå¿œã™ã‚‹ã‹ã‚’è¦³å¯Ÿã—ã¾ã—ã‚‡ã†ã€‚AIã¯ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¼·ãã€åˆ¥ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¼±ã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            </ul>
        </div>

        <div class="game-area">
            <div class="player-turn" id="playerTurn">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1 (èµ¤)</div>
            <div class="board-container">
                <div class="board" id="gameBoard">
                    </div>
            </div>
            <div class="button-group">
                <button id="findOptimalMoveButton">æœ€é©è§£ã‚’æ¢ã™</button>
                <button id="resetBoardButton">ç›¤é¢ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <div id="optimalMoveOutput">ã“ã“ã«AIã®æœ€é©è§£ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        </div>

        <p>ã‚ˆã‚Šæ·±ãå­¦ã³ãŸã„å ´åˆã¯ã€Connect Fourã®ã€ŒåŠ›æˆ¦å®šçŸ³ã€ã‚„ã€Œã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°ç†è«–ã€ã«ã¤ã„ã¦èª¿ã¹ã¦ã¿ã¦ãã ã•ã„ã€‚</p>
    </div>

    <script>
        const rows = 6;
        const cols = 7;
        const boardElement = document.getElementById('gameBoard');
        const playerTurnElement = document.getElementById('playerTurn');
        const findOptimalMoveButton = document.getElementById('findOptimalMoveButton');
        const resetBoardButton = document.getElementById('resetBoardButton');
        const optimalMoveOutput = document.getElementById('optimalMoveOutput');

        let board = Array(rows).fill(0).map(() => Array(cols).fill(0)); // 0:ç©º, 1:ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1(èµ¤), 2:ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2(é»„)
        let currentPlayer = 1; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ãŒå…ˆè¡Œ

        // ç›¤é¢ã‚’åˆæœŸåŒ–ãƒ»æç”»ã™ã‚‹é–¢æ•°
        function createBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    updateCell(cell, board[r][c]);
                    cell.addEventListener('click', () => handleCellClick(c));
                    boardElement.appendChild(cell);
                }
            }
            updatePlayerTurnDisplay();
        }

        // ã‚»ãƒ«ã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateCell(cellElement, player) {
            cellElement.classList.remove('player1', 'player2', 'empty');
            if (player === 1) {
                cellElement.classList.add('player1');
            } else if (player === 2) {
                cellElement.classList.add('player2');
            } else {
                cellElement.classList.add('empty');
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updatePlayerTurnDisplay() {
            playerTurnElement.textContent = `ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${currentPlayer} (${currentPlayer === 1 ? 'èµ¤' : 'é»„'})`;
        }

        // ã‚»ãƒ«ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ™‚ã®å‡¦ç† (é§’ã‚’è½ã¨ã™)
        function handleCellClick(col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    board[r][col] = currentPlayer;
                    const cellElement = boardElement.querySelector(`[data-row="${r}"][data-col="${col}"]`);
                    updateCell(cellElement, currentPlayer);
                    
                    // å‹åˆ©åˆ¤å®š
                    if (checkWin(board, currentPlayer)) {
                        optimalMoveOutput.textContent = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${currentPlayer}ã®å‹åˆ©ã§ã™ï¼`;
                        disableBoardClicks();
                        return;
                    }
                    
                    // å¼•ãåˆ†ã‘åˆ¤å®š
                    if (getAvailableMoves(board).length === 0) {
                        optimalMoveOutput.textContent = `å¼•ãåˆ†ã‘ã§ã™ï¼`;
                        disableBoardClicks();
                        return;
                    }

                    currentPlayer = (currentPlayer === 1) ? 2 : 1;
                    updatePlayerTurnDisplay();
                    optimalMoveOutput.textContent = 'ã“ã“ã«AIã®æœ€é©è§£ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚'; // ç›¤é¢å¤‰æ›´ã§ãƒªã‚»ãƒƒãƒˆ
                    return;
                }
            }
            optimalMoveOutput.textContent = `åˆ— ${col + 1} ã¯æº€æ¯ã§ã™ã€‚`;
        }

        // ãƒœãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯ã‚’ç„¡åŠ¹ã«ã™ã‚‹
        function disableBoardClicks() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.pointerEvents = 'none';
            });
        }

        // ãƒœãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯ã‚’æœ‰åŠ¹ã«ã™ã‚‹
        function enableBoardClicks() {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.pointerEvents = 'auto';
            });
        }

        // ç›¤é¢ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        resetBoardButton.addEventListener('click', () => {
            board = Array(rows).fill(0).map(() => Array(cols).fill(0));
            currentPlayer = 1;
            createBoard();
            optimalMoveOutput.textContent = 'ã“ã“ã«AIã®æœ€é©è§£ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚';
            enableBoardClicks();
        });

        // =========================================================================
        // AI (Minimax with Alpha-Beta Pruning) ãƒ­ã‚¸ãƒƒã‚¯
        // =========================================================================

        const WIN_SCORE = 1000000; // å‹åˆ©ã®è©•ä¾¡ç‚¹
        const LOSE_SCORE = -WIN_SCORE; // æ•—åŒ—ã®è©•ä¾¡ç‚¹

        // ãƒœãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function copyBoard(board) {
            return board.map(row => [...row]);
        }

        // é§’ã‚’è½ã¨ã›ã‚‹è¡Œã‚’è¦‹ã¤ã‘ã‚‹
        function getNextEmptyRow(board, col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    return r;
                }
            }
            return -1; // åˆ—ãŒæº€æ¯
        }

        // åˆ©ç”¨å¯èƒ½ãªæ‰‹ï¼ˆé§’ã‚’ç½®ã‘ã‚‹åˆ—ï¼‰ã‚’å–å¾—ã™ã‚‹
        function getAvailableMoves(board) {
            const moves = [];
            for (let c = 0; c < cols; c++) {
                if (board[0][c] === 0) { // æœ€ä¸Šæ®µãŒç©ºãªã‚‰ãã®åˆ—ã¯ã¾ã ç½®ã‘ã‚‹
                    moves.push(c);
                }
            }
            return moves;
        }

        // å‹åˆ©åˆ¤å®š
        function checkWin(boardState, player) {
            // æ°´å¹³æ–¹å‘
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (boardState[r][c] === player &&
                        boardState[r][c+1] === player &&
                        boardState[r][c+2] === player &&
                        boardState[r][c+3] === player) {
                        return true;
                    }
                }
            }

            // å‚ç›´æ–¹å‘
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c < cols; c++) {
                    if (boardState[r][c] === player &&
                        boardState[r+1][c] === player &&
                        boardState[r+2][c] === player &&
                        boardState[r+3][c] === player) {
                        return true;
                    }
                }
            }

            // å³ä¸ŠãŒã‚Šæ–œã‚
            for (let r = 3; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (boardState[r][c] === player &&
                        boardState[r-1][c+1] === player &&
                        boardState[r-2][c+2] === player &&
                        boardState[r-3][c+3] === player) {
                        return true;
                    }
                }
            }

            // å³ä¸‹ãŒã‚Šæ–œã‚
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (boardState[r][c] === player &&
                        boardState[r+1][c+1] === player &&
                        boardState[r+2][c+2] === player &&
                        boardState[r+3][c+3] === player) {
                        return true;
                    }
                }
            }
            return false;
        }

        // ç›¤é¢è©•ä¾¡é–¢æ•° (Connect Four AIã®è³¢ã•ã®éµ)
        function evaluateBoard(boardState, player) {
            let score = 0;
            const opponent = (player === 1) ? 2 : 1;

            // å„æ–¹å‘ã«4ã¤ã®é€£ç¶šã™ã‚‹é§’ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©•ä¾¡
            function scoreWindow(window, isPlayer) {
                let pCount = 0;
                let oppCount = 0;
                let emptyCount = 0;

                for (let piece of window) {
                    if (piece === player) {
                        pCount++;
                    } else if (piece === opponent) {
                        oppCount++;
                    } else {
                        emptyCount++;
                    }
                }

                // **æ”¹å–„ç‚¹: 4ã¤æƒã„ã¨3ã¤æƒã„ï¼ˆã‚ªãƒ¼ãƒ—ãƒ³ï¼‰ã®è©•ä¾¡ã‚’ã•ã‚‰ã«å¼·èª¿**
                if (pCount === 4) return WIN_SCORE;
                if (oppCount === 4) return LOSE_SCORE; // ç›¸æ‰‹ã®å‹ã¡ã‚’å³åº§ã«èªè­˜

                if (pCount === 3 && emptyCount === 1) return 1000; // è‡ªåˆ†ã®ã‚ªãƒ¼ãƒ—ãƒ³ãª3ã¤ä¸¦ã³
                if (oppCount === 3 && emptyCount === 1) return -900; // ç›¸æ‰‹ã®ã‚ªãƒ¼ãƒ—ãƒ³ãª3ã¤ä¸¦ã³ (éå¸¸ã«å±é™º)

                if (pCount === 2 && emptyCount === 2) return 100; // è‡ªåˆ†ã®ã‚ªãƒ¼ãƒ—ãƒ³ãª2ã¤ä¸¦ã³
                if (oppCount === 2 && emptyCount === 2) return -90; // ç›¸æ‰‹ã®ã‚ªãƒ¼ãƒ—ãƒ³ãª2ã¤ä¸¦ã³

                return 0;
            }

            // ä¸­å¤®ã®åˆ—ã‚’å„ªå…ˆã™ã‚‹ (çµŒé¨“å‰‡ã€æˆ¦ç•¥çš„ä¾¡å€¤ãŒé«˜ã„)
            for (let r = 0; r < rows; r++) {
                if (boardState[r][3] === player) score += 5; // ä¸­å¤®ã«ã‚ˆã‚Šé«˜ã„è©•ä¾¡
                else if (boardState[r][3] === opponent) score -= 5;
            }

            // å…¨ã¦ã®æ–¹å‘ã®4ãƒã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è©•ä¾¡
            // æ°´å¹³æ–¹å‘
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    const window = [boardState[r][c], boardState[r][c+1], boardState[r][c+2], boardState[r][c+3]];
                    score += scoreWindow(window);
                }
            }

            // å‚ç›´æ–¹å‘
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    const window = [boardState[r][c], boardState[r+1][c], boardState[r+2][c], boardState[r+3][c]];
                    score += scoreWindow(window);
                }
            }

            // å³ä¸ŠãŒã‚Šæ–œã‚æ–¹å‘
            for (let r = 3; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    const window = [boardState[r][c], boardState[r-1][c+1], boardState[r-2][c+2], boardState[r-3][c+3]];
                    score += scoreWindow(window);
                }
            }

            // å³ä¸‹ãŒã‚Šæ–œã‚æ–¹å‘
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    const window = [boardState[r][c], boardState[r+1][c+1], boardState[r+2][c+2], boardState[r+3][c+3]];
                    score += scoreWindow(window);
                }
            }

            return score;
        }

        // Minimaxã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  (å†å¸°é–¢æ•°)
        function minimax(boardState, depth, alpha, beta, maximizingPlayer, currentPlayerValue) {
            const opponentPlayerValue = (currentPlayerValue === 1) ? 2 : 1;

            // çµ‚äº†æ¡ä»¶:
            // 1. æ·±ã•åˆ¶é™ã«é”ã—ãŸ
            // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ãŒå‹åˆ©ã—ãŸ
            // 3. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ãŒå‹åˆ©ã—ãŸ
            // 4. å¼•ãåˆ†ã‘ï¼ˆæ‰‹ãŒãªã„ï¼‰
            
            // çµ‚äº†æ¡ä»¶ãƒã‚§ãƒƒã‚¯ã®é †ç•ªã‚‚é‡è¦ã€‚å‹åˆ©ãƒ»æ•—åŒ—ã¯å¸¸ã«æœ€å„ªå…ˆã€‚
            if (checkWin(boardState, 1)) {
                return (1 === currentPlayerValue) ? WIN_SCORE : LOSE_SCORE;
            }
            if (checkWin(boardState, 2)) {
                return (2 === currentPlayerValue) ? WIN_SCORE : LOSE_SCORE;
            }
            if (getAvailableMoves(boardState).length === 0) {
                return 0; // å¼•ãåˆ†ã‘
            }
            if (depth === 0) {
                return evaluateBoard(boardState, currentPlayerValue);
            }

            const availableMoves = getAvailableMoves(boardState);
            // ä¸­å¤®ã«è¿‘ã„åˆ—ã‹ã‚‰æ¢ç´¢ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ã«è‰¯ã„æ‰‹ã‚’è¦‹ã¤ã‘ã‚„ã™ãã™ã‚‹
            availableMoves.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));

            if (maximizingPlayer) { // AI (maximizingPlayer) ã®ç•ª
                let maxEval = -Infinity;
                for (let col of availableMoves) {
                    const row = getNextEmptyRow(boardState, col);
                    if (row !== -1) {
                        const newBoard = copyBoard(boardState);
                        newBoard[row][col] = currentPlayerValue;
                        const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, opponentPlayerValue); // ç›¸æ‰‹ã®ç•ª
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        if (beta <= alpha) break; // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Š
                    }
                }
                return maxEval;
            } else { // ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (minimizingPlayer) ã®ç•ª
                let minEval = Infinity;
                for (let col of availableMoves) {
                    const row = getNextEmptyRow(boardState, col);
                    if (row !== -1) {
                        const newBoard = copyBoard(boardState);
                        newBoard[row][col] = opponentPlayerValue;
                        const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, currentPlayerValue); // AIã®ç•ª
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        if (beta <= alpha) break; // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Š
                    }
                }
                return minEval;
            }
        }

        // æœ€é©ãªæ‰‹ã‚’è¦‹ã¤ã‘ã‚‹é–¢æ•°
        findOptimalMoveButton.addEventListener('click', () => {
            optimalMoveOutput.innerHTML = 'è¨ˆç®—ä¸­... <span class="loading-spinner"></span>';
            disableBoardClicks(); // è¨ˆç®—ä¸­ã¯ç›¤é¢æ“ä½œã‚’ç„¡åŠ¹åŒ–

            // éåŒæœŸã§è¨ˆç®—ã‚’å®Ÿè¡Œã—ã€UIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„
            setTimeout(() => {
                const availableMoves = getAvailableMoves(board);
                if (availableMoves.length === 0) {
                    optimalMoveOutput.textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†ã§ã™ã€‚';
                    enableBoardClicks();
                    return;
                }

                let bestMove = -1;
                let bestScore = -Infinity; // AIã«ã¨ã£ã¦æœ€é«˜ã®ã‚¹ã‚³ã‚¢
                // æ¢ç´¢ã®æ·±ã• (AIã®è³¢ã•ã¨è¨ˆç®—é€Ÿåº¦ã®ãƒãƒ©ãƒ³ã‚¹)
                // 4ï½6ç¨‹åº¦ãŒãƒ–ãƒ©ã‚¦ã‚¶ã§ç¾å®Ÿçš„ãªç¯„å›²
                const depth = 5; // æ¢ç´¢æ·±ã•ã‚’å°‘ã—æ·±ãè¨­å®š (èª¿æ•´å¯èƒ½)

                // å¯èƒ½ãªæ‰‹ã‚’è©•ä¾¡
                // ä¸­å¤®ã«è¿‘ã„åˆ—ã‹ã‚‰è©¦ã™ã“ã¨ã§ã€è¦‹ã¤ã‘ã‚„ã™ããªã‚‹
                const sortedMoves = [...availableMoves].sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));

                for (let col of sortedMoves) {
                    const newBoard = copyBoard(board);
                    const row = getNextEmptyRow(newBoard, col);
                    if (row !== -1) {
                        newBoard[row][col] = currentPlayer; // ä»®ã«AIã®é§’ã‚’ç½®ã
                        
                        // ã“ã®ä¸€æ‰‹ã§å‹åˆ©ã™ã‚‹å ´åˆã€ãã‚ŒãŒæœ€å„ªå…ˆã®æœ€é©è§£
                        if (checkWin(newBoard, currentPlayer)) {
                            bestMove = col;
                            bestScore = WIN_SCORE;
                            break; 
                        }

                        // Minimaxã§ç›¸æ‰‹ã®æœ€å–„æ‰‹ã‚’è€ƒæ…®ã—ãŸä¸Šã§ã®è©•ä¾¡
                        // ã“ã“ã§ `currentPlayer` ã‚’ `maximizingPlayer` ã®è¦–ç‚¹ã¨ã—ã¦æ¸¡ã™
                        const score = minimax(newBoard, depth - 1, -Infinity, Infinity, false, currentPlayer); 
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = col;
                        }
                    }
                }

                if (bestMove !== -1) {
                    let message = `AIãŒæ¨å¥¨ã™ã‚‹æœ€é©è§£ã¯ **åˆ— ${bestMove + 1}** ã§ã™ã€‚`;
                    if (bestScore === WIN_SCORE) {
                        message += ` (ã“ã®ä¸€æ‰‹ã§AIãŒå‹åˆ©ã—ã¾ã™ï¼ ğŸ‰)`;
                    } else if (bestScore <= LOSE_SCORE + 100) { // è² ã‘ãŒç¢ºå®šã«è¿‘ã„å ´åˆ
                        message += ` (ã“ã®ä¸€æ‰‹ã§ã‚‚AIã®æ•—åŒ—ã¯é¿ã‘ã‚‰ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“... ğŸ˜¥)`;
                    } else if (bestScore >= WIN_SCORE - 100) { // å‹åˆ©ãŒè¦‹ãˆã‚‹ãŒã€ã¾ã å®Œå…¨ã§ã¯ãªã„å ´åˆ
                        message += ` (ã“ã®æ‰‹ã§AIãŒéå¸¸ã«æœ‰åˆ©ãªå±€é¢ã«ãªã‚Šã¾ã™ï¼)`
                    }
                    optimalMoveOutput.innerHTML = message;
                } else {
                    optimalMoveOutput.textContent = 'æœ€é©ãªæ‰‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚'; 
                }
                enableBoardClicks(); // è¨ˆç®—çµ‚äº†å¾Œã€ç›¤é¢æ“ä½œã‚’æœ‰åŠ¹åŒ–
            }, 10); // çŸ­ã„é…å»¶ã‚’å…¥ã‚Œã¦UIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
        });

        // åˆæœŸè¡¨ç¤º
        createBoard();
    </script>
</body>
</html>
