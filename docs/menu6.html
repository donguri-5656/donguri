<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect Four Solver</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* 上部に寄せる */
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            /* モバイルでのピンチズームを防ぐ */
            touch-action: manipulation;
        }

        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
            max-width: 700px;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(7, 60px); /* 7列 */
            grid-template-rows: repeat(6, 60px);    /* 6行 */
            gap: 5px;
            background-color: #007bff; /* 青色の盤面 */
            padding: 10px;
            border-radius: 5px;
            margin: 20px auto;
            width: fit-content; /* 内容に合わせて幅を調整 */
            position: relative; /* 子要素のabsolute配置の基準 */
        }

        /* 各列の上部に配置するクリックエリア */
        .column-click-area {
            grid-row: 1 / span 6; /* 1行目から6行目まで全体をカバー */
            z-index: 10; /* セルより手前に表示 */
            cursor: pointer;
            /* デバッグ用: クリックエリアの範囲を見たい場合にコメントアウトを外す */
            /* background-color: rgba(0, 255, 0, 0.1); */
        }

        .cell {
            width: 60px;
            height: 60px;
            background-color: #f0f8ff; /* 穴の初期色（薄い青） */
            border-radius: 50%; /* 丸い穴 */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease-in-out;
            position: relative; /* ディスクの色変更を重ねるため */
            z-index: 5; /* column-click-areaより奥 */
        }

        .cell.player1 {
            background-color: #ff4500; /* プレイヤー1 (赤) */
        }

        .cell.player2 {
            background-color: #000000; /* プレイヤー2 (黒) */
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #reset-button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #reset-button:hover {
            background-color: #218838;
        }

        .message {
            font-size: 18px;
            font-weight: bold;
            color: #555;
        }

        .solver-suggestion {
            margin-top: 30px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            text-align: left;
        }

        .solver-suggestion h2 {
            color: #0056b3;
            margin-top: 0;
            margin-bottom: 10px;
        }

        #solver-advice {
            font-size: 1.1em;
            color: #333;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Connect Four Solver</h1>
        <div id="game-board" class="game-board"></div>
        <div class="controls">
            <button id="reset-button">リセット</button>
            <div class="message" id="message"></div>
        </div>
        <div class="solver-suggestion">
            <h2>ソルバーの提案</h2>
            <p id="solver-advice">盤面を入力してください...</p>
        </div>
    </div>

    <script>
        const ROWS = 6;
        const COLS = 7;
        const EMPTY = 0;
        const PLAYER1 = 1; // 赤 (先行)
        const PLAYER2 = 2; // 黒 (後攻)

        let board = [];
        let currentPlayer = PLAYER1; // プレイヤー1 (赤) が先行

        const gameBoardElement = document.getElementById('game-board');
        const resetButton = document.getElementById('reset-button');
        const messageElement = document.getElementById('message');
        const solverAdviceElement = document.getElementById('solver-advice');

        // ゲームボードの初期化
        function initializeBoard() {
            board = Array(ROWS).fill(0).map(() => Array(COLS).fill(EMPTY));
            currentPlayer = PLAYER1;
            renderBoard();
            updateMessage(`プレイヤー${currentPlayer === PLAYER1 ? '1 (赤)' : '2 (黒)'} の番です`);
            updateSolverAdvice();
            enableClicks(); // リセット時にクリックを再度有効化
        }

        // ボードの描画
        function renderBoard() {
            gameBoardElement.innerHTML = ''; // 既存の要素をクリア

            // 各列の上部にクリック可能なエリアを作成し、イベントリスナーを追加
            for (let c = 0; c < COLS; c++) {
                const columnClickArea = document.createElement('div');
                columnClickArea.classList.add('column-click-area');
                columnClickArea.dataset.col = c;
                // CSS Gridで正しい列に配置
                columnClickArea.style.gridColumn = `${c + 1}`;
                columnClickArea.addEventListener('click', handleColumnClick);
                gameBoardElement.appendChild(columnClickArea);
            }

            // ゲームセルを描画
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    if (board[r][c] === PLAYER1) {
                        cell.classList.add('player1');
                    } else if (board[r][c] === PLAYER2) {
                        cell.classList.add('player2');
                    }
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    // CSS Gridで正しい行と列に配置
                    cell.style.gridRow = `${r + 1}`;
                    cell.style.gridColumn = `${c + 1}`;
                    gameBoardElement.appendChild(cell);
                }
            }
        }

        // 列全体がクリックされた時の処理
        function handleColumnClick(event) {
            const col = parseInt(event.target.dataset.col);
            if (dropDisc(col, currentPlayer)) {
                if (checkWin(currentPlayer)) {
                    updateMessage(`プレイヤー${currentPlayer === PLAYER1 ? '1 (赤)' : '2 (黒)'} の勝利！`);
                    disableClicks(); // ゲーム終了後はクリック無効化
                } else if (isBoardFull()) {
                    updateMessage('引き分け！');
                    disableClicks();
                } else {
                    currentPlayer = (currentPlayer === PLAYER1) ? PLAYER2 : PLAYER1;
                    updateMessage(`プレイヤー${currentPlayer === PLAYER1 ? '1 (赤)' : '2 (黒)'} の番です`);
                    updateSolverAdvice();
                }
            } else {
                updateMessage('その列には置けません。別の列を選んでください。');
            }
        }

        // ディスクをドロップする
        function dropDisc(col, player) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === EMPTY) {
                    board[r][col] = player;
                    renderBoard(); // ディスクを置いた後にボードを再描画
                    return true;
                }
            }
            return false; // その列は満杯
        }

        // 勝敗判定
        function checkWin(player, currentBoard = board) {
            // 水平方向
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c <= COLS - 4; c++) {
                    if (currentBoard[r][c] === player &&
                        currentBoard[r][c+1] === player &&
                        currentBoard[r][c+2] === player &&
                        currentBoard[r][c+3] === player) {
                        return true;
                    }
                }
            }

            // 垂直方向
            for (let r = 0; r <= ROWS - 4; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (currentBoard[r][c] === player &&
                        currentBoard[r+1][c] === player &&
                        currentBoard[r+2][c] === player &&
                        currentBoard[r+3][c] === player) {
                        return true;
                    }
                }
            }

            // 右下がり斜め
            for (let r = 0; r <= ROWS - 4; r++) {
                for (let c = 0; c <= COLS - 4; c++) {
                    if (currentBoard[r][c] === player &&
                        currentBoard[r+1][c+1] === player &&
                        currentBoard[r+2][c+2] === player &&
                        currentBoard[r+3][c+3] === player) {
                        return true;
                    }
                }
            }

            // 右上がり斜め
            for (let r = 3; r < ROWS; r++) {
                for (let c = 0; c <= COLS - 4; c++) {
                    if (currentBoard[r][c] === player &&
                        currentBoard[r-1][c+1] === player &&
                        currentBoard[r-2][c+2] === player &&
                        currentBoard[r-3][c+3] === player) {
                        return true;
                    }
                }
            }

            return false;
        }

        // ボードが満杯かチェック
        function isBoardFull(currentBoard = board) {
            return currentBoard[0].every(cell => cell !== EMPTY);
        }

        // クリックを無効化する
        function disableClicks() {
            const clickAreas = document.querySelectorAll('.column-click-area');
            clickAreas.forEach(area => {
                area.removeEventListener('click', handleColumnClick);
                area.style.cursor = 'default';
            });
        }

        // クリックを有効化する
        function enableClicks() {
            const clickAreas = document.querySelectorAll('.column-click-area');
            clickAreas.forEach(area => {
                area.addEventListener('click', handleColumnClick);
                area.style.cursor = 'pointer';
            });
        }

        // メッセージの更新
        function updateMessage(msg) {
            messageElement.textContent = msg;
        }

        // ソルバーのアドバイスを更新
        function updateSolverAdvice() {
            const advice = getSolverAdvice(currentPlayer);
            solverAdviceElement.innerHTML = advice; // innerHTMLを使うことでHTMLタグを反映
        }

        // 指定した列で次にディスクを置ける行を取得
        function getNextAvailableRow(col, currentBoard = board) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (currentBoard[r][col] === EMPTY) {
                    return r;
                }
            }
            return -1; // その列は満杯
        }

        // N個連続をカウントする補助関数（特定のプレイヤーの全てのN個連続パターンを数える）
        function countNInARow(currentBoard, player, count) {
            let totalCount = 0;

            // 水平
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c <= COLS - count; c++) {
                    let streak = 0;
                    for (let i = 0; i < count; i++) {
                        if (currentBoard[r][c + i] === player) {
                            streak++;
                        } else {
                            streak = 0;
                            break; // 連続が途切れたら次のチェックへ
                        }
                    }
                    if (streak === count) totalCount++;
                }
            }

            // 垂直
            for (let r = 0; r <= ROWS - count; r++) {
                for (let c = 0; c < COLS; c++) {
                    let streak = 0;
                    for (let i = 0; i < count; i++) {
                        if (currentBoard[r + i][c] === player) {
                            streak++;
                        } else {
                            streak = 0;
                            break;
                        }
                    }
                    if (streak === count) totalCount++;
                }
            }

            // 右下がり斜め
            for (let r = 0; r <= ROWS - count; r++) {
                for (let c = 0; c <= COLS - count; c++) {
                    let streak = 0;
                    for (let i = 0; i < count; i++) {
                        if (currentBoard[r + i][c + i] === player) {
                            streak++;
                        } else {
                            streak = 0;
                            break;
                        }
                    }
                    if (streak === count) totalCount++;
                }
            }

            // 右上がり斜め
            for (let r = count - 1; r < ROWS; r++) {
                for (let c = 0; c <= COLS - count; c++) {
                    let streak = 0;
                    for (let i = 0; i < count; i++) {
                        if (currentBoard[r - i][c + i] === player) {
                            streak++;
                        } else {
                            streak = 0;
                            break;
                        }
                    }
                    if (streak === count) totalCount++;
                }
            }
            return totalCount;
        }

        // ソルバーのロジック（簡易版）
        function getSolverAdvice(player) {
            const opponent = (player === PLAYER1) ? PLAYER2 : PLAYER1;
            let adviceHtml = '';
            const playerColorName = player === PLAYER1 ? '赤' : '黒';
            const opponentColorName = opponent === PLAYER1 ? '赤' : '黒';

            // --- 現在のプレイヤー (自分の番) の視点 ---
            adviceHtml += `**現在のプレイヤー（${playerColorName}）の視点:**<br>`;

            // 1. 自分の勝利手を探す
            let foundWinningMove = false;
            for (let c = 0; c < COLS; c++) {
                const r = getNextAvailableRow(c);
                if (r !== -1) {
                    board[r][c] = player; // 仮置き
                    if (checkWin(player)) {
                        board[r][c] = EMPTY; // 元に戻す
                        adviceHtml += `&emsp;・**列 ${c + 1} に置けば、${playerColorName}の勝利です！**<br>`;
                        foundWinningMove = true;
                        // 勝利手が見つかったら、これ以上の複雑な分析は不要なのでここで終了
                        return adviceHtml;
                    }
                    board[r][c] = EMPTY; // 元に戻す
                }
            }

            // 2. 相手の勝利をブロックする手を探す
            let foundBlockingMove = false;
            for (let c = 0; c < COLS; c++) {
                const r = getNextAvailableRow(c);
                if (r !== -1) {
                    board[r][c] = opponent; // 相手が置いたと仮定
                    if (checkWin(opponent)) {
                        board[r][c] = EMPTY; // 元に戻す
                        adviceHtml += `&emsp;・**列 ${c + 1} は相手（${opponentColorName}）の勝利を防ぐために重要です。**<br>`;
                        foundBlockingMove = true;
                    }
                    board[r][c] = EMPTY; // 元に戻す
                }
            }

            // 3. 自分の3つ並びチャンスを探す（次の手で4つになる可能性）
            let playerOpportunities = [];
            for (let c = 0; c < COLS; c++) {
                const r = getNextAvailableRow(c);
                if (r !== -1) {
                    board[r][c] = player; // 仮置き
                    if (countNInARow(board, player, 3) > 0) {
                        playerOpportunities.push(`列 ${c + 1}`);
                    }
                    board[r][c] = EMPTY; // 元に戻す
                }
            }
            if (playerOpportunities.length > 0) {
                adviceHtml += `&emsp;・${playerColorName}は**列 ${playerOpportunities.join(', ')}**に置くことで、次の勝利につながる3つ並びの形を作れます。<br>`;
            }

            // 4. 中央に近い列を優先する (他の優先度が高い手がない場合)
            if (!foundWinningMove && !foundBlockingMove && playerOpportunities.length === 0) {
                const preferredCols = [3, 2, 4, 1, 5, 0, 6]; // 中央に近い列
                let centralMoveSuggested = false;
                for (const col of preferredCols) {
                    if (getNextAvailableRow(col) !== -1) {
                        adviceHtml += `&emsp;・他に目立った手がない場合、中央に近い**列 ${col + 1}**は一般的に有利な位置です。<br>`;
                        centralMoveSuggested = true;
                        break;
                    }
                }
                if (!centralMoveSuggested) {
                    adviceHtml += `&emsp;・現在の盤面では、特に推奨される手はありません。好きな空いている列に置いてみましょう。<br>`;
                }
            }

            // --- 相手プレイヤーの視点 ---
            adviceHtml += `<br>**相手プレイヤー（${opponentColorName}）の視点:**<br>`;

            // 1. 相手の勝利手を探す（もし自分の番が相手だったら）
            for (let c = 0; c < COLS; c++) {
                const r = getNextAvailableRow(c);
                if (r !== -1) {
                    board[r][c] = opponent; // 相手が置いたと仮定
                    if (checkWin(opponent)) {
                        board[r][c] = EMPTY; // 元に戻す
                        adviceHtml += `&emsp;・もし相手の番だったら、**列 ${c + 1}**に置くことで${opponentColorName}が勝利できます。注意が必要です！<br>`;
                    }
                    board[r][c] = EMPTY; // 元に戻す
                }
            }

            // 2. 相手が自分の勝利をブロックする可能性
            // ここでは、自分が置いた後、相手がブロックしないと自分が勝てるような場所（危険な場所）を指摘
            let dangerousColumnsForOpponent = [];
            for (let c = 0; c < COLS; c++) {
                const r = getNextAvailableRow(c);
                if (r !== -1) {
                    board[r][c] = player; // 自分が仮に置いた場合
                    // その後、相手がその列に置かないと自分が勝てるかチェック
                    // このロジックはより複雑なMinimaxでないと完全には難しいが、簡易的に
                    // 自分が置いた後、その列に空きがあり、相手がそこを放置すると自分が勝てる状況
                    let opponentCanBlock = false;
                    const nextR = getNextAvailableRow(c, board); // 自分が置いた後の次の空き
                    if (nextR !== -1) {
                         board[nextR][c] = opponent; // 相手がその場所をブロックした場合
                         if (checkWin(player, board) === false) { // 自分が勝てなくなるならブロック成功
                             opponentCanBlock = true;
                         }
                         board[nextR][c] = EMPTY; // 元に戻す
                    }

                    if (checkWin(player) && !opponentCanBlock) { // 自分が勝てるが、相手がブロックできない場合
                         // このパターンは稀で、通常は直接的な勝利手として上部で検出される
                    }
                    board[r][c] = EMPTY; // 元に戻す
                }
            }


            // 3. 相手の3つ並びチャンス（もし相手の番だったら）
            let opponentOpportunities = [];
            for (let c = 0; c < COLS; c++) {
                const r = getNextAvailableRow(c);
                if (r !== -1) {
                    board[r][c] = opponent; // 相手が仮置き
                    if (countNInARow(board, opponent, 3) > 0) {
                        opponentOpportunities.push(`列 ${c + 1}`);
                    }
                    board[r][c] = EMPTY; // 元に戻す
                }
            }
            if (opponentOpportunities.length > 0) {
                adviceHtml += `&emsp;・もし相手の番だったら、**列 ${opponentOpportunities.join(', ')}**で3つ並びの形を作れます。<br>`;
            }

            // アドバイスが少ない場合の補足
            if (adviceHtml.indexOf('勝利です！') === -1 && adviceHtml.split('<br>').length < 6) { // 勝利アドバイスがなく、行数が少ない場合
                adviceHtml += `<br>その他のアドバイス:<br>&emsp;・より詳細な分析には、本格的なAI（Minimaxなど）が必要です。このソルバーは、現在の盤面での直接的な脅威やチャンスを重点的に分析しています。<br>`;
            }


            return adviceHtml;
        }

        // イベントリスナー
        resetButton.addEventListener('click', initializeBoard);

        // 初期描画
        initializeBoard();
    </script>
</body>
</html>
